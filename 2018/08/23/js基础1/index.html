<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "20615c0a"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ECMAScript,语法以及api," />





  <link rel="alternate" href="/atom.xml" title="Sanr's Blog" type="application/atom+xml" />






<meta name="description" content="javaScript基本语法">
<meta name="keywords" content="ECMAScript,语法以及api">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript">
<meta property="og:url" content="https://chensanr.gitee.io/2018/08/23/js基础1/index.html">
<meta property="og:site_name" content="Sanr&#39;s Blog">
<meta property="og:description" content="javaScript基本语法">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://chensanr.gitee.io/images/web/default.jpg">
<meta property="og:image" content="https://chensanr.gitee.io/images/web/defer.png">
<meta property="og:image" content="https://chensanr.gitee.io/images/web/默认继承.png">
<meta property="og:image" content="https://chensanr.gitee.io/images/web/1-自定义-原型链继承.png">
<meta property="og:image" content="https://chensanr.gitee.io/images/web/组合.png">
<meta property="og:updated_time" content="2022-01-25T09:14:59.642Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript">
<meta name="twitter:description" content="javaScript基本语法">
<meta name="twitter:image" content="https://chensanr.gitee.io/images/web/default.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chensanr.gitee.io/2018/08/23/js基础1/"/>





  <title>ECMAScript | Sanr's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sanr's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">三日的一二事</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chensanr.gitee.io/2018/08/23/js基础1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sanr Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p88z46ccj.bkt.clouddn.com/avar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sanr's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ECMAScript</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T09:19:28+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/javaScript/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  23,934
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  97
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote><p>javaScript基本语法</p>
</blockquote>
<p><img src="/images/web/default.jpg" alt="目录"><a id="more"></a><br>本文记录了本人在大三期间自学javaScript的学习笔记，自学时用到的代码均上传至github。该部分主要介绍的是js基本语法，是js的核心知识点。</p>
<h1 id="javaScript的基本语法"><a href="#javaScript的基本语法" class="headerlink" title="javaScript的基本语法"></a>javaScript的基本语法</h1><ol>
<li><p>javaScript简介</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js的历史：</span><br><span class="line">    javascript是1995年诞生的，当时是为了处理以前由服务器语言负责的没有填写的必填域，是否输入了有效的值的判断。由网景公司开发而成的LIVEScript,后来搭了java的顺风车改成javascript,因为是不共享的，后来不同的浏览器形成了不同的javascript，后期为了开发者的方便就从不同的浏览器中的javascript提出相同的核心的部分称为ECMAScript,作为javascript的实现标准。</span><br><span class="line"></span><br><span class="line">    javascript包括ECMAScript(核心js)，BOM和DOM(浏览器提供的).</span><br><span class="line">    java和javascript几乎没有任何关系。</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li><p>脚本语言</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标记语言:html,没有逻辑能力和行为能力，只能够被读取</span><br><span class="line">脚本语言：js,本身具有行为能力和逻辑能力，需要被浏览器解析(浏览器内置解析器)执行</span><br><span class="line">编译语言：java,本身具有行为能力和逻辑能力，需要编译运行</span><br><span class="line">                需要进行.class编译（javac） 运行（java）</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释性语言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浏览器中内置解析器（用来解析执行代码）</span><br><span class="line">    火狐：js解析器</span><br><span class="line">    谷歌：js解析器</span><br><span class="line">        编译型语言</span><br><span class="line">            Java C</span><br><span class="line">                .java-&gt;.class   字节码</span><br><span class="line">                .c   -&gt;.o       二进制</span><br><span class="line">                    编译：语法校验</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱类型语言<br>   javascript：</p>
<pre><code>弱类型语言（语言宽松）
    var a=12;//a:number
        a=&quot;hello&quot;;//a:string 正确
        a=true;//a:boolean;
</code></pre><p>   java:</p>
<pre><code>强类型语言（语言严格）
    int a=12;
        a=&quot;hello&quot;;//代码报错
</code></pre></li>
<li>从上往下顺序解析执行<br>   html:从上往下</li>
</ul>
</li>
<li><p>javascript的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">一个完整的javascript的实现包括三个部分：ECMAScript（核心js），DOM，BOM</span><br><span class="line">    ECMAScript（核心js）</span><br><span class="line">        ECMA-262 定义的EMCAScript与Web浏览器没有依赖关系。浏览器仅是ECMAScript实现可能的宿主环境之一，宿主环境不仅提供基本的ECMAScript实现同时也提供该语言的扩展，以便语言与环境之间对接交互。扩展如DOMECMA规定了这门语言的组成部分</span><br><span class="line">        1，语法</span><br><span class="line">        2，类型</span><br><span class="line">        3，语句</span><br><span class="line">        4，关键字</span><br><span class="line">        5，保留字</span><br><span class="line">        6，操作符</span><br><span class="line">        7，对象（万物皆对象）</span><br><span class="line">    DOM（文档对象模型）</span><br><span class="line">        DOM(Document Object Model) 是针对XML但经过扩展用于HTML的应用程序编程接口。DOM将整个页面映射成一个多节点结构。</span><br><span class="line">                html代码：</span><br><span class="line">                &lt;html&gt;</span><br><span class="line">                    &lt;head&gt;</span><br><span class="line">                        &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">                        &lt;meta&gt;</span><br><span class="line">                    &lt;/head&gt;</span><br><span class="line">                    &lt;body&gt;</span><br><span class="line">                        &lt;p&gt;nihao &lt;/p&gt;</span><br><span class="line">                        &lt;!--注释节点--&gt;</span><br><span class="line">                    &lt;/body&gt;</span><br><span class="line">                &lt;/html&gt;</span><br><span class="line">                    dom模型</span><br><span class="line">                    doucment</span><br><span class="line">                        |</span><br><span class="line">                    html节点</span><br><span class="line">                    /   \</span><br><span class="line">                head    body</span><br><span class="line">                 |       |</span><br><span class="line">                title    p</span><br><span class="line">                 |       |</span><br><span class="line">                &apos;hello&apos; &apos;你好&apos;</span><br><span class="line">    BOM（浏览器对象模型）</span><br><span class="line">        alert()也属于</span><br><span class="line">        </span><br><span class="line">        BOM(Browser Object Model),开发人员可以使用BOM控制浏览器显示的页面以外的部分。弹出新浏览器窗口；移动，缩放，关闭浏览器的功能；提供浏览器详细信息的navigator对象;提供浏览器所加载页面的详细信息的location对象；提供用户显示器分辨率详细信息的screen对象；对cookies的支持；支持XMLHttpRequest,IE中的ActiveXObject自定义对象</span><br><span class="line"></span><br><span class="line">        BOM和DOM之间的关系，由于BOM的核心对象是window，window对象有一个document属性，而document是DOM的根节点，所以BOM可以操作DOM.</span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性</p>
<ul>
<li>JavaScript的三个组成部分，在当前五个主要浏览器（IE,Firefox,Chrom,Safari,Opera）中得到了不同程度支持，其中，所有浏览器对ECMAScript3支持大体都还不错，对ECMAScript支持程度越来越高，但对DOM的支持彼此相差较多，对已经正式纳入HTML5标准的BOM来说，尽管各浏览器都实现了某些总所周知的共同特性，但其他特性还因浏览器而异。</li>
</ul>
</li>
<li><p>script标签的属性</p>
<ul>
<li>type: 可看做是language的替代属性(language已废弃)，表示编写代码使用的脚本语言的内容类型，MIME这个属性非必须，默认是text/javascript</li>
<li><p>src: 表示包含要执行代码的外部文件（与用link标签引入的css样式表中的href相区别）</p>
</li>
<li><p>async：立刻下载脚本，但应妨碍页面中其他操作（只针对外部脚本文件）</p>
</li>
<li>charset:指定src属性指定的代码的字符集，大多数浏览器会忽略这个值。</li>
<li>defer: 表示脚本可以延迟到文档全部被解析和显示之后再执行（只针对外部脚本文件）</li>
</ul>
</li>
<li><p>在HTML中使用JavaScript</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.直接嵌入在页面中</span><br><span class="line">   将js代码嵌入在head标签(body标签，或者body之后html之后的标签)内部</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;/*js代码*/&lt;/script&gt;</span><br><span class="line">   将js代码嵌入在html标签内部</span><br><span class="line">        &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;div onclick=&quot;alert(&quot;hello&quot;);&quot;&gt;&lt;/div&gt;</span><br><span class="line">3.引入外部的js文件</span><br><span class="line">    不能再已经引入外部文件的script标签内部书写js代码，否则会被浏览器忽略执行</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;js/1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.不要在&lt;script&gt;标签中再填写其他js代码，否则将会忽略(引入外部的js文件方式)</span><br><span class="line"></span><br><span class="line">2.src 可以跨域访问 。例如：http://cdn.code.baidu.com/ 百度静态资源公共库(后期的ajax跨域访问)</span><br><span class="line"></span><br><span class="line">3.script标签位置&lt;head&gt;标签中：等到全部的js代码都被下载,解释和执行完成后才能开始呈现页面的内容。可将代码引用放到&lt;body&gt;元素放到内容后面。</span><br><span class="line"></span><br><span class="line">4.延迟脚本:(defer=&quot;defer&quot;),延迟至浏览器遇到&lt;/html&gt;标签后再执行。</span><br><span class="line"></span><br><span class="line">5.&lt;noscript &gt;当浏览器不支持脚本或者浏览器支持脚本，脚本被禁用，可以让页面平稳的退化.</span><br><span class="line">&lt;/noscript&gt;</span><br><span class="line">    &lt;noscript&gt;</span><br><span class="line">        本页面需要浏览器支持（启用）javascript</span><br><span class="line">    &lt;/noscript&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基础语法<br> 1) 区分大小写 </p>
<pre><code>typeof 关键字， typeOf 非关键字
</code></pre><p> 2) 标识符<br>   指变量，函数，属性的名字或者函数的参数。标识符是按照以下规则组合起来的一或多个字符：</p>
<pre><code>1.字母，数字，下划线，$组成。
2.只能以字母，下划线，$开头。
3.不能将关键字作为标识符。
4.命名尽量采用驼峰式命名
</code></pre><p> 3) 注释</p>
<pre><code>//单行注释
/*
多行注释
*/
</code></pre><p> 4) 语句<br> 每个语句以分号结尾，如果省略分号，由解析器确定语句的结尾，即分号可以省略，但是我们要求每个语句的末尾都应该有分号</p>
</li>
<li><p>关键字保留字<br> 1) 关键字:(在js中有特殊功能)</p>
<pre><code>break       do      instanceof  typeof
case        else    new,        var
catch       finally return,     void
continue    for     switch,     while
debugger    this    function    with
default     if      throw       delete
in          try
</code></pre><p> 2) 保留字：(将来可能成为关键字)</p>
<pre><code>abstract    enum    int         short
boolean     export  interface   static
byte        extends long        super
char        final   native      synchronized
class       float   package     throws
const       goto    private     transient
debugger    double  implements  protected
volatile    import  public
</code></pre></li>
<li><p>script标签的defer和async属性（异步加载：无阻塞并发处理）：建议使用defer，但是它只对外部js有效。</p>
<ul>
<li><p>正常情况下，当浏览器在解析HTML源文件时如果遇到外部script,那么解析过程会暂停，并发送请求来下载script，只有script完全下载并执行后才会继续执行DOM解析。但是通过script的async或者defer属性来让脚本不必同步（一步一步按步骤）执行。</p>
</li>
<li><p>async和defer都不会暂停HTML解析就立刻被下载，两者都支持onload事件回调来解决需要该脚本来执行的初始化。两者都只能用在外部JS文件中。</p>
</li>
<li><p>两者的区别在于执行时的不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async h5新增属性，用于异步下载脚本文件，下载完成后立即解析执行代码。</span><br><span class="line">脚本在script文件下载完成后立即执行，并且执行时间一定在window的load事件触发之前，但不确定与DOMContentLoaded事件的执行顺序，这意味着多个script脚本很可能不会按照其在页面出现的顺序执行。</span><br><span class="line">load事件一般是在HTML中指定的资源都加载完成之后触发的，比如图片什么的。</span><br><span class="line"></span><br><span class="line">defer 开启新线程下载脚本文件，并使脚本在文档解析完成后执行。</span><br><span class="line">脚本执行时间为DOM解析完成之后，document的DOMContentLoaded事件和load事件触发之前。浏览器确保多个defer脚本按其在HTML页面出现顺序来依次执行。</span><br><span class="line">DOMContentLoaded事件是在DOM加载完，也就是HTML和JS解析完成之后就触发的。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>页面的加载和渲染过程</p>
<ul>
<li>浏览器通过HTTP协议请求服务器，服务器返回响应页面。（浏览器）获取HTML文档（响应页面）并开始从上到下解析（浏览器解析器），构建DOM.</li>
<li>在构建DOM过程中，如果遇到外联样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件。</li>
<li>样式文件下载完成之后，构建CSSDOM，脚本文件下载完成之后，解释并执行。然后继续解析文档DOM</li>
<li><p>完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口</p>
</li>
<li><p>在这一整个过程中，脚本文件的下载和执行是与文档解析同步执行的，也就是说会阻塞文档的解析，如果控制的不好，在用户体验上就会造成不同程度的影响。<br>defer and async图片：<a href="/images/web/defer.png">地址</a><br><img src="/images/web/defer.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<h2 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>创建变量</p>
<ul>
<li>变量声明<br>   var str;</li>
<li><p>变量初始化<br>   赋值操作<br>   str =”arrsy”;</p>
</li>
<li><p>变量的更改<br>   str =2;<br>   str =true;</p>
</li>
<li>变量的使用<br>   console.log(str);//true<br>   打印在控制台上<br>   str = str+”hello”;//truehello</li>
<li>变量的声明和初始化<br>var arr1 =[1,2,3];<br>var arr2 =[3,4,2];<br>var arr =[arr1,arr2];</li>
<li><p>声明多个变量<br>var str1 =”hello”,str2 =”ls”,str3=”ld”;</p>
<p>1.var age =12;<br>2.age =12;</p>
</li>
</ul>
</li>
<li><p>全局变量和局部变量</p>
<p> 全局变量声明的两种方式：</p>
<pre><code>用var声明在script标签内部的
不用var声明在script标签内的任意位置处
     若没有用var声明在函数体内部的变量只有在函数被调用并且执行到变量声明处才有这个全局变量，并且能被使用。
        function test(){
            message = &quot;hello&quot;;  
        }
        // test();
        alert(message); //可以访问 没有用var 声明的变量属于全局变量，当函数被调用之后页面就有了这个全局变量
</code></pre><p> 局部变量：用var 声明在块中（方法体中）</p>
<pre><code>function test(){
  var message = &quot;hello&quot;;  
}
test();
alert(message); //错误 局部变量只能在局部作用域内访问
</code></pre></li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><p>分类<br> <strong>ECMAScript不支持自定义类型，只有6种数据类型：</strong></p>
<ul>
<li><p>5中基本数据类型（简单数据类型）<br>  Undefined 未定义 “undefined”</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a ;</span><br><span class="line">var a = undefined;</span><br></pre></td></tr></table></figure>
<p>  Null    空引用数据类型 “null”</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br></pre></td></tr></table></figure>
<p>  Boolean   布尔类型 true/false</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = false;</span><br></pre></td></tr></table></figure>
<p>  Number    数字类型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数(八进制 十进制 十六进制)</span><br><span class="line">浮点数(小数)</span><br></pre></td></tr></table></figure>
<p>  String    字符串类型 “” ‘’</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; &apos;hello&apos;</span><br><span class="line">var a =&quot;undefined&quot;;</span><br><span class="line">var a =&apos;hello&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1种引用数据类型（复杂数据类型）<br>  <strong>Object(本质由一组无序的键值对组成)</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">var teacher=new Obejct();</span><br><span class="line">typeof(student)//object</span><br><span class="line">teacher.age=12;</span><br><span class="line">teacher.gender=&quot;男&quot;;</span><br><span class="line">console.log(teacher.age);//12</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">var student=&#123;</span><br><span class="line">    name:&quot;zhangsan&quot;,</span><br><span class="line">    age:12</span><br><span class="line">&#125;;//空对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>typeof操作符(该方法本身会返回一个字符串类型)<br>   <strong>返回该变量名所指向数据的类型</strong><br>   语法：<br>   typeof 变量名  console.log(typeof(a));</p>
<p>   可有取值如下</p>
<pre><code>&quot;undefined&quot;   未定义
&quot;boolean&quot;   布尔类型
&quot;string&quot;    字符串
&quot;number&quot;    数值

&quot;object&quot;    对象或者null
&quot;function&quot;    函数
</code></pre></li>
<li><p>instanceof操作符 返回布尔值，用来判断是否属于某个构函的实例</p>
<pre><code>var stu =new Object();
console.log(stu instanceof Object);//true

function eat(){

}
console.log(eat instanceof Function);//true
console.log(eat instanceof Object);//true
</code></pre></li>
<li><p>数据类型</p>
</li>
</ol>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>   值是undefined的几种情况（类型也是undefined）</p>
<ol>
<li><p>变量声明但未赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);//undefined</span><br><span class="line">console.log(typeof(a));//&apos;undefined&apos;</span><br><span class="line"></span><br><span class="line">//typeof()方法返回字符串类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>将变量值显式设置为undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=undefined;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(typeof(a));</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个未声明的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(a);//报错 试图获取一个未声明的变量</span><br><span class="line">console.log(typeof(a));//不报错 没有声明的变量的类型是&apos;undefined&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问变量没有的属性时</p>
</li>
<li>函数没有返回值的时候</li>
</ol>
<h5 id="null-空引用数据类型，即将要指向一个引用数据类型"><a href="#null-空引用数据类型，即将要指向一个引用数据类型" class="headerlink" title="null: 空引用数据类型，即将要指向一个引用数据类型"></a>null: 空引用数据类型，即将要指向一个引用数据类型</h5><p>   值为null,类型为Object类型<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a =null;</span><br><span class="line">console.log(a);//null</span><br><span class="line">console.log(typeof(a));//&apos;Object&apos;</span><br><span class="line"></span><br><span class="line">undefined是派生自Null的，</span><br><span class="line">console.log(null==undefined);//true 相等不全等</span><br><span class="line">console.log(null===undefined);//false</span><br></pre></td></tr></table></figure></p>
<p>   <strong>使用情景</strong><br>   如果一个变量准备将来保存对象，可以将该变量初始化null而不是其他，这样可以通过检查null值就可以知道相应的变量是否已经保存了一个对象的引用。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(car !=null )&#123;</span><br><span class="line">//car对象执行某些操作</span><br><span class="line">&#125;</span><br><span class="line">实际上 undefined 派生自null值。undefined == null 结果为 true</span><br><span class="line">null与undefined用途不同，null可以用来表示一个空对象，但是没有必要把一个变量的值显式设置为undefined</span><br></pre></td></tr></table></figure></p>
<h5 id="boolean-布尔类型"><a href="#boolean-布尔类型" class="headerlink" title="boolean: 布尔类型"></a>boolean: 布尔类型</h5><pre><code>该类型只有两个值，true,false虽然boolean类型的取值只有两个，但是ECMAScript中所有的类型的值都有与这两个Boolean值等价的值
除了null undefined 0 &quot;&quot; NaN false 是false，其余都可以转换为true
    var c =true;
    var b =false;
    console.log(c);//true
    console.log(typeof c);//boolean
    var d =Boolean(a);//null转换为布尔值为false
    var e =Boolean(b);
    console.log(d);//false
    console.log(typeof d);//boolean
    console.log(e);//false
    console.log(typeof e);//boolean
</code></pre><h5 id="number-数值类型"><a href="#number-数值类型" class="headerlink" title="number: 数值类型"></a>number: 数值类型</h5><p><strong>分为整型和浮点型</strong><br>一： 表示方法</p>
<ol>
<li><p>整数：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十进制数： 55  0~9</span><br><span class="line">八进制数： 首位为0,其他位为（0~7 如果字面值超出了范围，前导0将会被忽略）</span><br><span class="line">    070 （表示 7*8一次方 =  56）</span><br><span class="line">    079 （超过了范围，表示79）</span><br><span class="line">十六进制： 前两位为0x，其他位为(0~9，A~F)</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>浮点数</p>
<pre><code>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后必须至少有一位数字。浮点数值的最高精度是17位小数。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如： var f = 1.2;</span><br><span class="line">科学计数法：e</span><br><span class="line">    var e = 3.125e7;    //31250000</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<p>二： 数值范围</p>
<ol>
<li><p>由于内存的限制，ECMAScript不能保存世界上所有的数值。ECMAScript能表示的最小数值保存在Number.MIN_VALUE中，能表示的最大的数值保存在Number.MAX_VALUE中。如果某次计算的结果超过了JavaScript数值范围，将会返回Infinity(正无极)或者-Infinity(负无极)</p>
</li>
<li><p>使用 isFinite()函数可以判断参数是否在最大值和最小值之间，如果在，返回true</p>
<p> 在绝大数浏览器中：<br> Number.MIN_VALUE ： 5e-324<br> Number.MAX_VALUE ：  1.7976931348623157e+308<br> 如果某次计算返回了正的或者负的Infinity,那么该值无法继续参与下一次计算。可以使用isFinite(para)函数判断para 是否在最大数最小数之间</p>
</li>
</ol>
<p>三： 非数值 NaN (not a number)<br>        <strong>该数值表示一个本来要返回数值的操作数未返回数据的情况。</strong><br>        var a = 10/‘a’;<br>        console.log(a);   //NaN<br>        <strong>任何涉及到NaN的操作都会返回NaN; NaN与任何值都不相等，包括NaN本身。</strong></p>
<pre><code>isNaN，判断参数是否“不是数值”或者不能转为为数值时，当参数para不是数值的时候返回true 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN);   true</span><br><span class="line">isNaN(&quot;blue&quot;);  true  无法转换为数值</span><br><span class="line">isNaN(10);    false 10</span><br><span class="line">isNaN(&quot;10&quot;);  false 10</span><br><span class="line">isNaN(true);  false</span><br><span class="line">console.log(0=== -0);  //TRUE</span><br><span class="line">console.log(NaN===NaN); //FALSE</span><br></pre></td></tr></table></figure>
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>默认情况下，ECMAScript会将小数点后带有6个零以上的浮点数转化为科学计数法。<br>0.0000003 =&gt; 3e-7(3*Math.pow(10,-7))  e=10</li>
<li>在进行算术计算时，所有以八进制十六进制表示的数值都会被转换成十进制数值。    </li>
<li>保存浮点数需要的内存是整数的两倍，因此ECMAScript会不失时机将浮点转换为整数(比如浮点数只有0的时候)<br>   例如：<br>   var a = 1.;<br>   var b = 1.0;  都将解析为1</li>
<li>避免测试某个特点的浮点数值，是使用IEEE 754数值的浮点计算的通病<br>例如： 0.1+0.2结果不是0.3，而是0.30000000000000004<br>Math.pow(2, 53)，十进制即 9007199254740992   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">// var p =0.1;</span><br><span class="line">// var o =0.2;</span><br><span class="line">// var result =p+o;</span><br><span class="line">// console.log(result);//失去精度 因为计算机解析的时候是32位的二进制数0和1  0.300000000004</span><br><span class="line"></span><br><span class="line">//失去精度的解决方法，把两个数变成整数，整数不会失去精度</span><br><span class="line">var p =0.1*10;</span><br><span class="line">var o =0.2*10;</span><br><span class="line">var result =(p+o)/10;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="String-字符串类型-“”-‘’"><a href="#String-字符串类型-“”-‘’" class="headerlink" title="String: 字符串类型 “” ‘’"></a>String: 字符串类型 “” ‘’</h5><p>   <strong>该类型表示由零个或者多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号或者单引号表示</strong><br>      1)字符字面量<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\n  换行</span><br><span class="line">\t  制表</span><br><span class="line">\b  退格</span><br><span class="line">\r  回车</span><br><span class="line">\\  斜杠</span><br><span class="line">(\&apos;)  (单引号)</span><br><span class="line">(\&quot;)  (双引号)</span><br></pre></td></tr></table></figure></p>
<pre><code>2)字符长度  
  通过length属性获取字符长度
</code></pre><h4 id="复杂数据类型：object"><a href="#复杂数据类型：object" class="headerlink" title="复杂数据类型：object"></a>复杂数据类型：object</h4><ol>
<li>ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行”new 对象类型”来创建。var o = new Object();</li>
<li>Object类型是所有它的实例的基础，换句话说,Object类型所具有的任何属性和方法，同样存在于更具体的对象。</li>
<li><p>Object.prototype中的属性和方法：</p>
<p>constructor:构造器，表示对象实例的构造函数。保存用户创建当前对象的函数</p>
<p>hasOwnProperty(propertyName): 用于检查给定的属性是否在当前对象实例中(属性为自己的则为true,如果是继承的则为false)</p>
<p>isPrototypeOf(object): 用于检查传入的对象是否是原型</p>
<p>propertyIsEnumerable(propertyName):用于检查给定的属性在当前对象实例中是否存在</p>
<p>toLocaleString();       返回对象的字符串表示，该字符串与执行环境的地区对应</p>
<p>toString();   返回对象的字符串表示<br>valueOf();    返回对象的字符串，数值，布尔值的表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    name:&quot;zhangsan&quot;,</span><br><span class="line">    age:21</span><br><span class="line">&#125;</span><br><span class="line">console.log(person.hasOwnProperty(&quot;gender&quot;));//false</span><br><span class="line">console.log(person.constructor)//object</span><br><span class="line">console.log(Object.prototype.isPrototypeOf(person)+&quot;looj&quot;); </span><br><span class="line">console.log(person.propertyIsEnumerable(&quot;name&quot;))//true</span><br><span class="line"></span><br><span class="line">var d = new Date()</span><br><span class="line">console.log(d.toLocaleString())//2017/8/16 下午11:24:59 </span><br><span class="line"></span><br><span class="line">var date = new Date(2013, 7, 18, 23, 11, 59, 230);</span><br><span class="line">document.write( date.toString() ); // Sun Aug 18 2013 23:11:59 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">var eles = document.getElementsByTagName(&quot;body&quot;);</span><br><span class="line">document.write( eles.toString() ); // [object NodeList]</span><br><span class="line">document.write( eles[0].toString() ); // [object HTMLBodyElement]</span><br><span class="line"></span><br><span class="line">var array = [&quot;CodePlayer&quot;, true, 12, -5];</span><br><span class="line">document.write( array.toString() ); // CodePlayer,true,12,-5</span><br></pre></td></tr></table></figure>
<p>对于不同类型的对象，js定义了多个版本的 toString 和 valueOf 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toString:</span><br><span class="line">（1）普通对象，返回 &quot;[object Object]&quot;;</span><br><span class="line">（2）数组，返回数组元素之间添加逗号合并成的字符串;（逗号也算这个字符串的长度）</span><br><span class="line">（3）函数，返回函数的定义式的字符串;</span><br><span class="line">（4）日期对象，返回一个可读的日期和时间字符串;（返回时期字符串）</span><br><span class="line">（5）正则，返回其字面量表达式构成的字符串;</span><br><span class="line"> (6) HTML节点：返回 [object HTMLBodyElement]</span><br><span class="line"></span><br><span class="line">valueOf:</span><br><span class="line">（1）日期对象，返回自1970年1月1日到现在的毫秒数;（返回数值）</span><br><span class="line">（2）其它均返回对象本身;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>其他数据类型转换为基本数据类型的boolean string number</strong></p>
<h4 id="强制转换（显式转换）"><a href="#强制转换（显式转换）" class="headerlink" title="强制转换（显式转换）"></a>强制转换（显式转换）</h4><ol>
<li><p>其他数据类型到Boolean类型转换<br> 通过Boolean() 函数转换<br> 除了0 null undefined “” NaN转换为false之外。其余的都转换为true.</p>
<pre><code>【Boolean   true      false】
 String      非空字符串   &quot;&quot;
 Number      任何非0     0和NaN
 Object      任何对象    null
 Undefined   n/a         undefined   (n/a not applicable 不适用)
</code></pre><p> 例如：</p>
<pre><code>Boolean(&quot;&quot;);        //false
Boolean(0);         //false
Boolean(NaN);       //false
Boolean(null)       //false
Boolean(undefined)  //false
Boolean(&quot;briup&quot;);   //true
Boolean(1);         //true
</code></pre></li>
<li><p>其他数据类型到数值类型转换</p>
<ol>
<li><p><strong>Number()</strong><br>1) 如果转换的值是null,undefined,boolean,number</p>
<pre><code>Number(undefined);  //NaN *
Number(true);       //1
Number(false);      //0
Number(null);       //0
Number(10);         //10 如果是数字值,原样输出
</code></pre><p>2) 如果是字符串：</p>
<pre><code>Number(&quot;&quot;);     //空字符串被转换为0

Number(&quot;123&quot;);  //如果仅包含数值，转换为对应的数值
Number(&quot;234.1&quot;);//解析为对应的小数
Number(&quot;+12.1&quot;);// 12.1 首位为符号位，其余为为数值，转换为对应的数值
Number(&quot;-12.1&quot;); //-12.1

Number(&quot;1+2.3&quot;);//NaN 符号位出现在非首位位置，解析为NaN *
Number(&quot;123ac&quot;);//包含其他字符： NaN *
Number(&quot;123/&quot;);//包含其他字符： NaN *

Number(&quot;0xa&quot;);  //如果仅包含十六进制格式，转为为对应的十进制的值
Number(&quot;010&quot;);  //【注意！】不会当做八进制被解析，结果为10

Number(&quot; 12&quot;);  //12
Number(&quot;1 2&quot;);  //NaN 非首位出现特殊字符(符号位和空格)转换为NaN *
</code></pre><p><strong>总结</strong>：</p>
<pre><code>1.转换为NaN的三种情况
      undefined
      当字符串里 符号位和空格出现在非首位的位置
      当字符串 包含其他字符时（包括英文字符和特殊字符/$&amp;*等）
2.其余的字符串类型都可以转换为数值，并且不解析字符串形式的八进制，忽略前导0直接进行输出；但是解析字符串的十六进制，会进行转换然后输出
3.符号位出现在首位的位置的字符串类型，是可以变成正数和负数的数值
</code></pre></li>
<li><p><strong>parseInt()</strong><br>1) 如果转换的值是null,undefined,boolean,number</p>
<pre><code>parseInt(true);     //NaN *
parseInt(false);    //NaN *
parseInt(null);     //NaN *
parseInt(undefined);//NaN *
parseInt(10);       //10 如果是整数值，原样输出
parseInt(10.3);     //10 如果是小数，舍去小数点一级后面的内容
parseInt(0);    //0
</code></pre><p>2) 如果是字符串：</p>
<pre><code>parseInt(&quot;&quot;);     //NaN；空字符串被转换为NaN *
parseInt(&quot;123&quot;);  //123；如果仅包含数值，转换为对应的数值
parseInt(&quot;234.1&quot;);//234；小数点后面的数值省略
parseInt(&quot;+12.1&quot;);//12； 首位为符号位，其余为为数值，转换为整数
parseInt(&quot;0xa&quot;);  //10； 如果仅包含十六进制(0x开头)格式，转为为对应的十进制的值
parseInt(&quot;010&quot;);  //10； 【注意！】不会当做八进制被解析，结果为10
parseInt(&quot;1+2.3&quot;);//1;  如果首位为数值，依次向后解析，找到连续的数值，直到遇到第一个非数值的，将之前获取的数值转换为Number返回
parseInt(&quot;123ac&quot;);//123;
</code></pre><p>3)进制的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = parseInt(3, 8)//八进制是0-7</span><br><span class="line">var b = parseInt(3, 2)//二进制只有0 1两个数组成 0-1</span><br><span class="line">var c = parseInt(3, 0)//十进制 0-9</span><br><span class="line">console.log(a);//3</span><br><span class="line">console.log(b);//NaN</span><br><span class="line">console.log(c);//3</span><br><span class="line"></span><br><span class="line">parseInt(&quot;10&quot;);     //返回 10</span><br><span class="line">parseInt(&quot;19&quot;,10);    //返回 19 (1*10 1次方+9**10 0次方)</span><br><span class="line">parseInt(&quot;11&quot;,2);   //返回 3 (1*2 1次方+1*2 0次方)</span><br><span class="line">parseInt(&quot;17&quot;,8);   //返回 15 (8+7)</span><br><span class="line">parseInt(&quot;1f&quot;,16);    //返回 31 (16+15)</span><br><span class="line">parseInt(&quot;010&quot;);    //当做十进制进行解析</span><br><span class="line">parseInt(&quot;0xa&quot;);    //当做十六进制进行解析</span><br></pre></td></tr></table></figure>
<p>parseInt(string, radix)<br>参数string  必需。要被解析的字符串。<br>参数radix   可选。表示要解析的数字的基数,即所保存数字的进制的值。该值介于 2 ~ 36 之间。<br>  如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。<br>  如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>
<p><strong>总结</strong>：</p>
<pre><code>1.转换为NaN的几种情况：
            &quot;&quot;   null undefined NaN boolean 以及 不包含数字的任意字符串

2.其他包含数字类型的字符串遵循 从前到后解析直到遇到特殊字符的时候就结束解析 并输出当前位置之前所解析的数值

3.剩下的字符串类型都可以转换为数值，并且不解析字符串形式的八进制，忽略前导0直接进行输出；但是解析字符串的十六进制，会进行转换然后输出

4.符号位出现在首位的位置的字符串，是可以变成正数和负数的数值
</code></pre></li>
<li><p><strong>parseFloat()</strong><br>与parseInt() 类似，特点基本上一致，但是有下面两点不同： </p>
<pre><code>1.字符串中的第一个小数点是有效的，而第二个小数点则无效其后的内容会被省略
2.始终忽略前导0（字符串为八进制和十六进制的都不会进行解析，直接输出）
    parseFloat(&quot;22.3.4&quot;)    //22.3
    parseFloat(&quot;022.34&quot;);   //22.34
</code></pre></li>
</ol>
</li>
<li><p>其他数据类型(这里不包括Object类型)到字符串类型转换</p>
<ol>
<li><p><strong>toString()函数</strong></p>
<p>(1)toString()函数是Object的一个方法，不能被基本数据类型调用，所以当基本数据类型来调用toString()方法来进行字符串数据转换时，<br>(2)浏览器会帮我们进行自动装箱和自动拆箱操作，使我们的基本数据类型能够调用toString()方法<br>(3)自动装箱：是把我们要调用toString()方法的基本数据类型的变量 封装成函数对象，使他能调用Object的toString()<br>(4)自动拆箱：是在进行装箱操作实现调用之后再进行拆箱 即把它从对象转换为原来声明在js中的变量值的默认类型<br>(5)注意：</p>
<ul>
<li><p>默认情况下，toString()是以十进制格式返回数值的字符串表示，通过传递参数，可以输入以二进制，八进制，十六进制乃至任意有效进制格式的字符串值</p>
<pre><code>var num = 10;       数值类型
num.toString();              &quot;10&quot;
      自动装箱成Number(num)
</code></pre><p>   随后进行自动拆箱Number(num)–&gt; num   </p>
<pre><code>num.toString(2);    &quot;1010&quot; 先把num转换为二进制再调用toString()方法
num.toString(8);    &quot;12&quot;   八进制输出
num.toString(16);   &quot;a&quot;   十六进制输出
</code></pre></li>
<li><p>所以number和boolean以及string是可以调用toString()方法</p>
</li>
<li>但是null ,undefined 没有toString() 方法<pre><code>null.toString()         //报错 TypeError: null has no properties   
undefined.toString();   //报错 TypeError: undefined has no properties
</code></pre></li>
</ul>
</li>
<li><p><strong>String() 构造函数</strong><br>不管你是什么数据类型的值都会转换成值为本身的一个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(null)         &quot;null&quot;</span><br><span class="line">String(true)         &quot;true&quot;</span><br><span class="line">String(12)              &quot;12&quot;</span><br><span class="line">String(undefined);   &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="自动转换（隐式转换）"><a href="#自动转换（隐式转换）" class="headerlink" title="自动转换（隐式转换）"></a>自动转换（隐式转换）</h4><ol>
<li>其他数据类型隐式转换为number<pre><code>一元运算符加+     a=+a;
一元运算符减-     a=-a;(如果是数值，直接为负号；如果不是，通过Number()转换为数值再变成负号)
算术运算符+       当m,n两个数不为String,Object类型的时候，先将m,n转换为Number类型，然后再进行计算
算术运算符-       返回值为【数值类型】。无论操作数为任何类型，先将其使用Number()转换器转换为Number类型，然后再计算。
算术运算符*      如果有一个操作数不是数值，则先调用Number()将其转换为数值
算术运算符/      如果有一个操作数不是数值，则先调用Number()将其转换为数值
算术运算符%      如果有一个操作数不是数值，则先调用Number()将其转换为数值
</code></pre></li>
<li>其他数据类型隐式转换为string<pre><code>+&quot;&quot;
加空字符串 3+&quot; &quot;=&quot;3&quot;;
</code></pre></li>
<li>其他数据类型隐式转换为boolean<pre><code>!!a;
    转换为布尔 !!2=true;
</code></pre></li>
</ol>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><pre><code>01) 一元操作符(都会先转换为 Number())
    ++,--,+,-操作符应用任何类型数值都返回一个【数值类型】，先将任意类型的值转换为Number然后进行运算(通过Number()方法进行转换)
    1.递增 ++  
        var a = &quot;11&quot;;
        console.log(1+ a++);//12
        console.log(1+ ++a);//14
        前置：先进行递增或者递减操作，在进行运算
        后置：先进行运算 再进行递增或者递减操作

        对任意数据类型的操作数都适用，

    ****使用前先将其转换为数字(Number())，然后再进行运算,
        在应用于对象的时候，优先先调用对象的valueOf方法，以取得一个可供操作的值,如果子类对象仅重写了toString(),调用该方法。

    2.递减 --
        前置：先进行递增或者递减操作 再进行运算
        后置：先进行运算 再递增或者递减操作

        对任意数据类型的操作数都适用，使用前先将其转换为数字(Number)，然后再进行运算在应用于对象的时候，先调用对象的valueOf方法，以取得一个可供操作的值,如果子类对象仅重写了toString(),调用该方法。

    3.一元加 +
        相当于调用Number();
        var a = &quot;12&quot;
        +a ;
            // 12  相当于调用了Number(&quot;12&quot;)
    4.一元减 -
        将一元减应用于数值时，数值会变成负数。
        将一元减应用于非数值时，遵循与一元加操作符相同的规则(转换为Number)，最后将得到的数值转化为负数

02) 布尔操作符, 非(NOT)
    逻辑非 !
    该操作符应用任何类型数值都返回一个【布尔值】。先将任意类型的数值转换为Boolean，然后取反，
        !a ==&gt; !Boolean(a)

        !null    //true
        !0      //true
        !&quot;&quot;     //true  
        !NaN    //true  
        !false  //true

        连用两次逻辑非 ，就可以将任意数据类型转化为Boolean类型，!!a ==&gt; Boolean(a)
        !!&quot;&quot;    //false 隐式转换

03) 逻辑与 &amp;&amp; (同真才真，有假则假) 也被称为短路运算符
    可应用于任意数值。如果有一个操作数不是布尔类型，逻辑与就不一定返回boolean类型

    如果第一个是false,则返回第一个数
    如果第一个是true,则返回第二个数

        var s1 = 8;
        var s2 = &quot;briup&quot;;
        var s3 = &quot;&quot;;
        var result  = s1 &amp;&amp; s2; //briup
        var result2 = s3 &amp;&amp; s2; //空字符串

04) 逻辑或 ||(有真则真，同假才假)
    如果第一个为true,则返回第一个数，
    如果第一个为false,则返回第二个数。

05) 加性操作符
    1. 加法 +
        m + n
        1) 当m,n不为String,Object类型的时候，先将m,n转换为Number类型，然后再进行计算
            true + false;     //1；Number(true)+Number(false);
            true + 1;     //2；Number(true) + 1
            null + undefined; //NaN；Number(undefined) -&gt; NaN
        2) 当m,n有一个为String,无论另一个操作数为何（但不为对象）都要转换为String，然后再进行拼接
            &quot;1&quot; + true; // 1true
            &quot;1&quot; + undefined;// 1undefined
            &quot;1&quot; + 1;    // 11
        3) 当m,n 有一个为对象，如果该对象既重写toString,又重写了valueOf方法，先调用valueOf方法获取返回值，将该返回值和另外一个操作数进行运算。如果该对象没有重写valueOf方法，将调用toString方法获取返回值，将该返回值和另外一个操作数进行运算。
            var o = {
                name:&quot;briup&quot;,
                valueOf:function(){
                    return &quot;1&quot;;
                }
            }
            o+1;        //11 直接参与运算，然后再根据加法前面两条规则来进行类型转换等，与减法的有对象类型的运算进行对比

    2. 减法 -
        返回值为【数值类型】。无论操作数为任何类型，先将其使用Number()转换器转换为Number类型，然后再计算。
        true - 1;       //0;    1-1
        null - true;    //-1 ;  0-1
        1 - undefined   //NaN
        var o = {
            name:&quot;briup&quot;,
            valueOf:function(){
                return &apos;1&apos;;
            }
        }
        o-1;        //0;    o调用valueOf方法，再根据减法前面的规则进行运算。返回了一个字符串类型  然后把它进行数值类型转换（根据原则是Number()，而不是前面加法的方式）  最后和1进行运算

    总结：加性操作符在运算时 遇到其中有一个为引用数据类型的时候会默认调用Object的toString()方法，
        当对象中重写了toString()方法时，则调用对象的toString()方法，当对象中重写了valueOf()方法，则调用valueOf()方法。
        如果对象既重写了toString()方法，又重写了valueOf()方法，则调用valueOf()方法。

        注意 toString()和 valueOf()方法两者写在对象里重写的话 都是以返回值的类型为基准，然后再根据加,减法各自的运算规则进行计算.

06) 乘性操作符
    返回值为【数值类型】,当操作数为非数值的时候执行自动的类型转化Number()

    1. 乘法 *
        如果两个数都是数值，执行常规的乘法计算
        如果一个操作数是NaN,结果为NaN（0*NaN=NaN）
        超过数值范围返回Infinity
        如果有一个操作数不是数值，则先调用Number()将其转换为数值。
    2. 除法 /
        如果一个操作数是NaN,结果为NaN （0/0 ; NaN）
        一个非0值除0 Infinity   
        如果有一个操作数不是数值，则先调用Number()将其转换为数值。
        var s1 = 5;
        var s2 = 2;
        var result = s1/s2;  //2.5
    3. 取余 %
        如果两个数都是数值，执行常规的取余计算
        如果一个操作数是NaN,结果为NaN（任意数%0 ; NaN）
        如果有一个操作数不是数值，则先调用Number()将其转换为数值

07) 关系操作符
    &lt; &gt; &lt;= &gt;= ,返回一个【Boolean】值
    1.如果两个操作数是字符串，比较字符串中对应位置的每个字符的字符编码值
        &quot;a&quot;&gt;&quot;b&quot; //false
        &quot;1&quot;&gt;&quot;a&quot; //false
    2.如果一个操作数是数值，将另外一个操作数也转换为数值Number()进行比较
        &quot;3&quot;&gt;1;          //true
        3&gt;true;         //true 3&gt;Number(true)
        3&gt;undefined;    //false Number(undefined)=NaN ;任何数和NaN比较结果都为false
    3.如果一个操作数是对象，默认调用toString(),如果对象重写了toString()方法，则调用toString；如果对象重写了valueOf()方法 则调用valueOf()方法；如果两个都重写了，则调用valueOf();

        var o = {
            name:&quot;briup&quot;,
            valueOf:function(){
                return &quot;13&quot;;
            }
        }
        o&gt;2     // true ; &quot;13&quot;&gt;2
        先调用toString或者valueOf方法，再根据前面的规则进行计算

08) 相等操作符,返回【Boolean】（比较内容）
    1.相等和不相等 ==, != (先转换在比较)
        1.如果两个操作数都为字符串，比较字符序列
        2.如果两个操作数都为数值类型，比较值的是否相等
        3.如果一个操作数为number类型，另外一个操作数为undefined,null,boolean,string之一，先将这些数据类型转换为数值，再进行比较
            var a=3;
            var b=&quot;4&quot;;
            a==b//false
        4.如果两个操作数都是对象，比较是的对象的引用地址
        5.null == undefined         //true    undefined 派生自null
        6.NaN与任何值（包括NaN）相等比较结果为false，不等结果为true.


    2.全等和不全等(比较类型和内容)
        仅比较不转换，先比较两个数所属的数据类型，如果类型不同则不同，如果类型相同，再继续比较两个数的值
        console.log(&quot;55&quot; == 55); true
        console.log(&quot;55&quot; === 55);false

    null与undefined是相等不全等的：
        null == undifined;      //true null派生自undifined
        null === undifined;     //false
        0 === -0 //true
09) 三目运算符 ? : 
    variable = boolean_expression ? true_value : false_value;
    如果boolean_expression为true,将true_value赋给variable，否则将false_value赋给variable

    例如：求任意两个数之间最大值
       function max(m,n){
            return m&gt;n?m:n; //如果m&gt;n为true返回m,如果m&gt;n为false,返回n
       }
10) 赋值运算符 = 
   将右侧的值赋给左侧的变量
   可以和其他算术运算符连用 *= %= += -= 等
   var a = 4;

   a *= 3; //=&gt; a = a*3;
11) 逗号操作符
   可以在一条语句中执行多个操作
   var num1=1,num2 = 2, num3 = 3;
</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>1.流程控制语句(先填框架再写代码)</p>
<ul>
<li>if语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(condition)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br><span class="line">condition表示任意表达式，该表达式求值的结果不一定是布尔类型，如果不是布尔类型，ECMAScript会调用Boolean() 转换函数将这个表达式结果转换为一个布尔类型，如果condition求值结果为true,执行statement1。如果求值结果为false，执行statement2</span><br><span class="line"></span><br><span class="line">if(condition)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;</span><br><span class="line">statement2;(此语句必然会执行)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>switch语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  switch(expression)&#123;</span><br><span class="line">      case val:</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line">      case val2:</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line">      default:</span><br><span class="line">  &#125;</span><br><span class="line">  ==&gt;</span><br><span class="line">  switch(expression)&#123;</span><br><span class="line">      case val:&#123;</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      case val2:&#123;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      default:</span><br><span class="line">  &#125;</span><br><span class="line">可以在switch语句中使用任何数据类型。</span><br><span class="line">case的值不一定是常量，也可以是变量，甚至是表达式。</span><br><span class="line"></span><br><span class="line">expression === val（两者比较的是全等）</span><br><span class="line">default:语句放在最后可以不加break;但是不放在最后需要加break;</span><br><span class="line"></span><br><span class="line">break 跳出循环执行下一条语句</span><br><span class="line">continue 跳出当前循环 执行下一次循环</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><p>循环语句 </p>
<ul>
<li><p>for语句<br>(1)for循环是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是for循环的语法：<br>初始化表达式，控制表达式，循环后表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(initialization;expression;post-loop-expression)&#123;</span><br><span class="line">    //loop option</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)三要素：<br>   初始条件<br>   结束条件(循环执行条件)<br>   迭代条件</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i=9;i&lt;=5;i++)&#123;</span><br><span class="line">    //循环体</span><br><span class="line">    console.log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var sum = 0;</span><br><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    sum +=i;</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); //10  </span><br><span class="line"></span><br><span class="line">ECMAScript不存在块级作用域，在循环内部定义的变量i也可以在外部访问到</span><br><span class="line">    </span><br><span class="line">死循环</span><br><span class="line">    1)for(;;)&#123;</span><br><span class="line">        //当for中的表达式省略的时候，会创建一个死循环</span><br><span class="line">    &#125;</span><br><span class="line">    2)while(true)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do-while语句 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i=1; </span><br><span class="line">do&#123;</span><br><span class="line">    </span><br><span class="line">&#125;while(condition);</span><br></pre></td></tr></table></figure>
<p>   后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。循环体内的代码最少被执行一次。</p>
</li>
<li><p>while语句<br>   开始条件<br>   结束条件<br>   迭代条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i=1;    </span><br><span class="line">while(结束条件)&#123;</span><br><span class="line">    迭代条件</span><br><span class="line">&#125;</span><br><span class="line">前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。</span><br><span class="line">while(false)&#123;</span><br><span class="line">    //不会执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for-in 语句（for循环增强）<br>   是一种精准的迭代语句，可以用来枚举对象的属性</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(property in expression)&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   例如:</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打印出window对象中所有的属性</span><br><span class="line">    for(var propName in window)&#123;</span><br><span class="line">        console.log(propName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="对象实例"><a href="#对象实例" class="headerlink" title="对象实例"></a>对象实例</h2><ol>
<li><p>创建对象的方式：</p>
<ul>
<li><p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">    name:&quot;ls&quot;,</span><br><span class="line">    &quot;first-name&quot;:&quot;zs&quot;,//当属性名包括特殊字符时必须用引号</span><br><span class="line">    age:12,</span><br><span class="line">    valueOf:function()&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Object()构函创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj=new Object();</span><br><span class="line">obj.name=&quot;zs&quot;;</span><br><span class="line">obj.age=12;</span><br><span class="line">delete obj.age;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装一个普通函数(工厂模式)</p>
</li>
<li>自定义的构造函数创建对象</li>
</ul>
</li>
<li><p>访问属性</p>
<ul>
<li>.语法<br>obj.name;</li>
<li>[]语法 方括号内部必须是一个字符串，也可以是一个类型是字符串的变量<br>obj[“name”];</li>
<li>把属性存放在变量内部，再通过方括号访问<br>var name=”name”;<br>obj[name];</li>
</ul>
</li>
<li><p>删除属性：delete关键字<br>   delete obj.name;<br>   只能删除对象的自有属性，不能删除继承属性<br>   销毁对象时，遍历对象的属性，依次删除属性，防止内存泄漏</p>
</li>
<li><p>检测属性：判断属性是否属于一个对象<br> 1)in:判断属性是否是一个对象的自有属性或者继承属性</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;name&quot; in obj);//true</span><br><span class="line">console.log(&quot;constructor&quot; in obj);//true</span><br></pre></td></tr></table></figure>
<p> 2)hasOwnProperty():判断属性是否是一个对象的自有属性</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.hasOwnProperty(&quot;name&quot;));//true</span><br><span class="line">console.log(obj.hasOwnProperty(&quot;constructor&quot;));//false</span><br></pre></td></tr></table></figure>
<p> 3)propertyIsEnumerable():检测给定属性是否是对象的自有属性，并且属性是可枚举的；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.propertyIsEnumerable(&quot;toString&quot;));//false</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历对象for-in<br> 函数中的属性名不会当做变量被解析。只会是字符串常量</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    name:&quot;ls&quot;,</span><br><span class="line">    age:12</span><br><span class="line">&#125;;</span><br><span class="line">for(var key in obj1)&#123;</span><br><span class="line">    console.log(key,obj1[key]); //用逗号分隔，打印的是字符串 以及 相应的属性值的类型  []能解析变量</span><br><span class="line">    // console.log(key+&quot; &quot;+obj1[key]);用+进行字符串拼接 结果是字符串之间的拼接</span><br><span class="line"> &#125;</span><br><span class="line">key是字符串类型的变量,代表的是每次遍历从obj中获取的属性名</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象序列化(JSON):轻量型的数据传输的格式</p>
<p> 1)所有的属性都必须用引号引起来的，方便前端中内存的数据传递给后台（前后台之间的交流方式）<br> 2)将对象转换为字符串 JSON.stringify()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var json =JSON.stringify(obj);//字符串 &#123;&quot;name&quot;:&quot;sds&quot;,&quot;age&quot;:13&#125;</span><br></pre></td></tr></table></figure>
<p> 3)字符串转换成对象 JSON.parse()</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var json2=&apos;&#123;&quot;name&quot;:&quot;sds&quot;,&quot;age&quot;:13&#125;&apos;;</span><br><span class="line">var obj2=JSON.parse(json2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的高级特性<br> 1)Object.defineProperty(对象，对象的属性，对象属性的一些相关特性);<br> 用来设置对象某个属性的特性值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj,&quot;weight&quot;,&#123;</span><br><span class="line">    value:&quot;80kg&quot;, //这个属性的值</span><br><span class="line">    enumerable:false,//是否可枚举，不能被遍历出来</span><br><span class="line">    writable:false //是否可写或可修改</span><br><span class="line">    configurable:是否可两次定义配置等</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 2)Object.defineProperties(对象，要设置的属性集合);<br> 用来设置对象某些属性的特性值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(obj,&#123;</span><br><span class="line">    gender:&#123;</span><br><span class="line">        value:&quot;male&quot;,</span><br><span class="line">        enumerable:true</span><br><span class="line">    &#125;,</span><br><span class="line">    height:&#123;</span><br><span class="line">        value:175,</span><br><span class="line">        enumerable:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 3)Object.getOwnPropertyDescriptor(obj,”属性”);用来检测某对象的某个属性的一些特性值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptor(arr,&quot;length&quot;));//writable属性为true 所以数组的长度是可变的</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object对象常用的属性和方法<br> Object 类型所具有的任何属性和方法也同样存在于其他对象中，任何对象继承于Object对象。<br> Object(通常放在原型中)中常用的方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor:      //保存用户创建当前对象的函数</span><br><span class="line">hasOwnProperty(propertyName); //检查给定的属性名是否是对象的自有属性，</span><br><span class="line">toString();     //返回对象的字符串表示</span><br><span class="line">valueOf();      //返回对象的字符串，数值，布尔值的表示。</span><br><span class="line">propertyIsEnumerable(propertyName); //检查给定的属性在当前对象实例中是否存在</span><br><span class="line">isPrototypeOf(object);    //检查传入的对象是否是原型</span><br><span class="line">toLocaleString();     //返回对象的字符串表示，该字符串与执行环境的地区对应</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><ol>
<li><p>声明<br> 1）函数声明（函数字面量）<br>   执行代码前会先提升函数声明并加载函数声明，<br>   函数声明不管在哪个地方都是有效的，只要在使用foo之前没有改变foo的值，访问foo时为function，若是改变了foo的值则使用foo则会变为改变后的值。</p>
<pre><code>function sayHello(){
    console.log(&quot;hello&quot;);
}
</code></pre><p> 2）函数表达式 有函数提升，不能把函数调用写在函数声明之前</p>
<pre><code>// var sayHello=undefined;函数提升变成undefined，不能在给函数赋值前调用，否则会报错。
var sayHello=function(){
    console.log(&quot;hello&quot;);
}
</code></pre><p> 3）构造函数Function()</p>
</li>
<li><p>函数的调用<br> sayHello(实参列表);<br> sayHello.call(执行环境对象this，实参列表);<br> sayHello.apply(执行环境对象，实参列表数组);</p>
</li>
<li><p>函数没有返回值(return)时返回undefined,</p>
</li>
<li><p>函数的内部属性arguments和this.特点是只能在函数内部运行<br>(1)arguments类数组对象：函数调用时实际参入函数的实际参数列表，其中有重要的两个属性，length属性和callee属性<br> 通常可以用来计算传入的任意个数之间和差乘除之间的算术运算</p>
<pre><code>1）length:是指函数调用时实际参入函数的参数个数
2）callee:保存的是这个函数 比如下面的函数中arguments.callee就是指add()，通常用来在阶乘中
        function add(){
            console.log(&quot;asdah&quot;);
        }
</code></pre><p>(2)this：指向的是函数赖以执行的对象<br>  直接调用函数是指向window<br>  对象调用方法是指向该对象</p>
</li>
<li><p>函数的属性和方法：<br> 1)length属性:指的是函数期望传入函数内部的参数，即形参个数，与函数内部arguments.length区分开<br> 2)call()方法：第一个参数是 this指向，第二个是参数列表<br> 3)apply()方法：第一个参数是 this指向，第二个是数组形式的参数列表</p>
</li>
<li><p>函数的运用<br> 函数可以作为参数使用<br> 函数可以作为函数的返回值</p>
</li>
<li><p>函数的高级特性<br> 构造器函数是一种特殊的对象，<br> 每一个函数对象对应一个原型对象（用来储存共享信息）<br> 在声明构造函数的同时会创建一个原型对象，可以用 构造函数.prototype指向这个原型对象，<br> 原型对象默认有一个constructor属性，保存的是这个构造函数<br> 用构造器函数创建的实例对象默认链接到函数的原型对象，<br> 原来是不能用实例对象访问原型对象的，后来可以使用<strong>proto</strong>属性访问原型对象</p>
</li>
</ol>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><ol>
<li>值传递：基本数据类型的传递，传递的是变量的值，在函数内部修改变量是不会改变外部的值<pre><code>var a=&quot;hello&quot;;
function test(a){
    a=&quot;pig&quot;;
    console.log(&quot;hshs&quot;);
}
test(a);
console.log(a);//&quot;hello&quot;
</code></pre></li>
<li>引用传递：引用数据类型的传递，传递的是对象的引用地址，在函数内部修改变量的会修改函数外部的值的。<pre><code>var a={
    name:&quot;ls&quot;,
    age:12
}
function test(a){
    a.name=&quot;pig&quot;;
    console.log(&quot;haha&quot;);
}
test(a);
</code></pre></li>
</ol>
<h3 id="undefined的取值情况"><a href="#undefined的取值情况" class="headerlink" title="undefined的取值情况"></a>undefined的取值情况</h3><p>  1)变量声明但未赋值<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a;//var a=undefined，显示声明未undefined类型</span><br><span class="line">console.log(a);//undefined</span><br></pre></td></tr></table></figure></p>
<p>  2)函数没有返回值时<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var result=test();</span><br><span class="line">console.log(result);//undefined</span><br></pre></td></tr></table></figure></p>
<p>  3)访问对象没有的属性<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">  name:&quot;ls&quot;,</span><br><span class="line">  age:12</span><br><span class="line">&#125;</span><br><span class="line">console.log(o.gender);//undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="函数提升和变量提升"><a href="#函数提升和变量提升" class="headerlink" title="函数提升和变量提升"></a>函数提升和变量提升</h3><ol>
<li><p>函数提升：</p>
<ul>
<li><p>函数声明的方式：在函数提升的同时加载函数，比函数表达式强大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test();</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">提升并加载后：</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式只会把函数提升到最上面，值为undefined.若函数调用写在声明之前会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var test = function()&#123;</span><br><span class="line">  console.log(&quot;pig&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">提升后：</span><br><span class="line">var test=undefined;//var test;</span><br><span class="line">test=function()&#123;</span><br><span class="line">  console.log(&quot;pig&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量提升：用var 声明的变量会在预解析的时候提升</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b=12;</span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br><span class="line">var a=&quot;pig&quot;;</span><br></pre></td></tr></table></figure>
<p> 函数提升和变量提升之后：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">  console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var a;//var a=undefined;</span><br><span class="line">b=12;</span><br><span class="line">console.log(a);//undefined</span><br><span class="line">a=&quot;pig&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>预解析时，函数提升在变量提升之前</p>
</li>
<li>回调函数：callback()，函数作为函数的参数<br> 好处：该怎么处理获取的数据由调用者本身决定 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//自己封装实现了一个forEach函数</span><br><span class="line">function hander(item,index)&#123;//函数声明，传入的是形参</span><br><span class="line">  console.log(item,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">forEach(arr,hander);</span><br><span class="line"></span><br><span class="line">    //封装 遍历数组的函数</span><br><span class="line">function forEach(arr,hander)&#123;</span><br><span class="line">  /*</span><br><span class="line">  for(var key in arr)&#123;</span><br><span class="line">    var item = arr[key];</span><br><span class="line">    hander.call(this,item,key);//实参</span><br><span class="line">  &#125;//key表示下标，此题中输出为字符串形式的下标值</span><br><span class="line">  */</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        var item =arr[i];</span><br><span class="line">        hander.call(this,item,i);//进行函数调用，传入的是实参</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="javaScript面向对象"><a href="#javaScript面向对象" class="headerlink" title="javaScript面向对象"></a>javaScript面向对象</h1><h2 id="封装（封装创建对象的函数）"><a href="#封装（封装创建对象的函数）" class="headerlink" title="封装（封装创建对象的函数）"></a>封装（封装创建对象的函数）</h2><p><strong>构造函数是创建对象的，构造函数首字母大写，普通函数是用来执行代码的</strong></p>
<ol>
<li><p>工厂函数模式<br>  封装一个普通函数，实现一个创建对象的函数<br>  只需调用函数传参就可创建一个对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function factory (id,name,age)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        id : id,</span><br><span class="line">        name:name,</span><br><span class="line">        age:age,</span><br><span class="line">        sayName:function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = factory(1,&apos;terry&apos;,12);</span><br><span class="line">var p2 = factory(2,&apos;larry&apos;,13);</span><br><span class="line">console.log(p1.sayName==p2.sayName);//false  内存地址不一样</span><br></pre></td></tr></table></figure>
<ul>
<li>数据类型无法细分 不能细分为自定义的一种类型</li>
<li>每创建一个对象，都要为这个对象初始化它的函数（函数在内存中重复创建）</li>
<li>如何实现函数复用：把这个函数提取出来，并把这个函数的地址赋值给函数中的函数属性值，但是这种方法不好，当函数比较多时，外部函数都写在外面不好管理。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function factory (id,name,age)&#123;</span><br><span class="line">return &#123;</span><br><span class="line">    id : id,</span><br><span class="line">    name:name,</span><br><span class="line">    age:age,</span><br><span class="line">    sayName:sayName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = factory(1,&apos;terry&apos;,12);</span><br><span class="line">var p2 = factory(2,&apos;larry&apos;,13);</span><br><span class="line">console.log(p1.sayName==p2.sayName);//true</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数模式</p>
<ul>
<li>构造函数在定义的时候会默认创建一个原型对象，这个原型是默认的，后期可以更改。<br>//扩展了引用数据类型 函数，对象，数组，正则对象</li>
<li><p>自定义一种数据类型 ,可以将实例标识为一种特定的类型，而不是直接属于Object（东西）的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(id,name,age)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">       console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu = new Student(1001,&quot;ls&quot;,12);</span><br><span class="line">console.log(stu);//函数没有返回值 stu为空</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数一般是通过new关键字调用。 var p1 = new Person(1,’larry’,12);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.解决了类型细分问题(instanceof可以判定对象的所属自定义类型等)</span><br><span class="line">    p1 instanceof Person</span><br><span class="line">    p1 instanceof Object</span><br><span class="line">2.没有解决函数存储的问题(只要是用var声明一个对象时，每一个方法都会被重新在内存中创建一个，除非把函数放在原型中)</span><br><span class="line">每创建一个实例对象就会创建一个函数，不能实现函数复用</span><br><span class="line"></span><br><span class="line">3.构造函数的创建对象步骤：</span><br><span class="line">    1) 创建一个新对象(new 关键字在内存中开辟一块空间 obj)</span><br><span class="line">    2) 将构造函数的作用域赋给新对象（this指向这个新对象obj）</span><br><span class="line">    3) 执行构造函数中的代码(通过构造函数给对象obj初始化)</span><br><span class="line">    4) 返回新对象obj。(并且把它赋值给用 var 声明的变量)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型模式与构造函数模式混用</p>
<ul>
<li><p>实例对象可以调用构造函数原型中的属性和方法</p>
</li>
<li><p>实例对象中定义的变量是实例变量，而原型中定义的变量可以叫公共变量或者类变量。</p>
</li>
<li><p>原则：将对象的自定义属性保存在对象中</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">讲对象可以调用的方法保存到构造函数原型中（共享）</span><br><span class="line">function Person(id,name,age)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>属性搜索原则：每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 首先从对象实例本身开始查找</span><br><span class="line">2) 如果不在对象实例中，则继续搜索指针指向的原型对象。</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除实例属性：当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性(属性或者方法重写)。通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete操作符可以完全删除实例属性。</span><br><span class="line">    var o=&#123;</span><br><span class="line">      toString:function()&#123;</span><br><span class="line">        return 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    o.toString();//调用的是O中重写的toString()方法，</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测属性：<br> 1)in 操作符，检测属性是否在实例对象或者原型中<br> 2)hasOwnProperty()方法，检测属性是否是在实例对象中</p>
</li>
<li><p>原生对象的原型：通过原生对象的原型，不仅可以取得所有默认方法的调用，而且可以定义新方法。可以向修改自定义对象的原型一样修改原生对象的原型，可以随时添加方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function(text)&#123;</span><br><span class="line">  return this.indexOf(text) == 0;</span><br><span class="line">&#125;</span><br><span class="line">var msg = &quot;Hello world&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;)); //true</span><br></pre></td></tr></table></figure>
</li>
<li><p>当原型中的方法较多的时候，可以将这些方法保存到一个对象中，然后将这个对象赋值给构造函数的原型，改变原有的默认原型对象。   这个新建的对象默认constructor指向Object,所以要显式改变它的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName:funciton()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    sayAge:function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>每次用构造函数创建一个对象时，都会调用一次构造函数并且给对象初始化。</p>
<h2 id="继承：本质是子构造函数的原型指向父构造函数的实例对象。"><a href="#继承：本质是子构造函数的原型指向父构造函数的实例对象。" class="headerlink" title="继承：本质是子构造函数的原型指向父构造函数的实例对象。"></a>继承：本质是子构造函数的原型指向父构造函数的实例对象。</h2><ul>
<li><p>是对象会有原型，原型本身也是对象，所有原型又有原型，如此往复构成原型链，直到Object.prototype 到 null结束。</p>
</li>
<li><p>定义：抽象，把各个底层相同的，相类似的东西抽象到顶层中，越具体的越在底层，越抽象的越在顶层，实现继承；若想要子构函中的方法不一样，则可以重写实现不一样的方法</p>
</li>
<li><p>问题：需不需要继承？<br>子函数的实例有时需要调用父函数原型中的方法，所以需要(继承)。<br>比如 Object.prototype中的toString,valueOf等方法</p>
</li>
<li><p>如何实现继承？</p>
<ol>
<li><p>默认继承：</p>
<ul>
<li><p>所有构造函数定义的时候都会默认创建一个原型对象，（即默认原型）</p>
</li>
<li><p>所有函数的默认原型 都是Object的实例，所以可以调用Object.prototype的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(id,name)&#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(1001,&quot;ls&quot;);</span><br><span class="line">p1.sayName();</span><br><span class="line"></span><br><span class="line">p1.toString();//可以调用Object.prototype的toString方法</span><br><span class="line">console.log(Person.prototype instanceof Object);</span><br></pre></td></tr></table></figure>
<p><img src="/images/web/默认继承.png" alt=""></p>
</li>
</ul>
</li>
<li><p>自定义继承</p>
<ul>
<li><p>属性继承：（经典继承）借用构造函数继承；解决子构造函数的属性继承父构造函数的属性，不必重复写代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Animal.call(this,id,name);</span><br><span class="line"></span><br><span class="line">function Animal(id,name)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name =name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Dog(id,name,color)&#123;</span><br><span class="line">  // Animal(id,name);进入Animal构函时，构函中的this指向window</span><br><span class="line">  </span><br><span class="line">  Animal.call(this,id,name);//用call调用函数时，Dog构函中的this指向赋值给了new这个新对象，所以call方法中的this就是这个保存的新对象。</span><br><span class="line"></span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.sayColor = function()&#123;</span><br><span class="line">  console.log(this.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法继承</p>
<p><strong>原型链继承：子构造函数的原型指向父构造函数创建的（实例）对象。（常用）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Animal(id,name)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog(id,name,color)&#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">Dog.prototype.sayColor = function()&#123;</span><br><span class="line">  console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var d2 = new Dog(1002,&quot;一休&quot;,&quot;yellow&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解析：</span><br><span class="line">  * Dog.prototype = new Animal();</span><br><span class="line">    这个操作要在创建对象之前做，不然会使创建的对象不能继承原型中的方法</span><br><span class="line">    </span><br><span class="line">  *  Dog.prototype.constructor = Dog;</span><br><span class="line">     要显示修改constructor,使它修改更彻底,如果不改变，那么new Animal这个实例本身没有constructor，会向上找它的原型，那么constructor默认就会是Animal构函。所以要显示修改它</span><br><span class="line"></span><br><span class="line">  * 如果在修改之前先创建了对象，这个对象将不会有原型中的方法，它指向默认原型。</span><br></pre></td></tr></table></figure>
<p>图片详细地址(高清):<a href="/images/web/1-自定义-原型链继承.png">原型继承</a><br><img src="/images/web/1-自定义-原型链继承.png" alt=""></p>
</li>
</ul>
</li>
<li><p>组合函数:原型链继承和借用构造函数继承相结合使用</p>
<ul>
<li>使用原型链实现对原型属性和方法的继承，而通过借用构造函数实现对实例属性的继承</li>
<li><p>在自构造函数中 Animal.call(this,id,name);   </p>
</li>
<li><p>在创建对象之前 Dog.prototype = new Animal();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function Animal(id,name)&#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.name =name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = function()&#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Dog(id,name,color)&#123;</span><br><span class="line">Animal.call(this,id,name);</span><br><span class="line">this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.sayColor = function()&#123;</span><br><span class="line">console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Bird(id,name,type)&#123;</span><br><span class="line">Animal.call(this,id,name);</span><br><span class="line">this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Bird.prototype = new Animal();</span><br><span class="line">Bird.prototype.constructor = Bird;</span><br><span class="line">Bird.prototype.sayType = function()&#123;</span><br><span class="line">console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line">var b1 = new Bird(1001,&quot;yixiu&quot;,&quot;八哥&quot;);</span><br><span class="line">var d1 = new Bird(1001,&quot;bd&quot;,&quot;yellow&quot;);</span><br><span class="line">b1.sayName();</span><br><span class="line">b1.sayType();</span><br><span class="line">d1.sayName();</span><br><span class="line">d1.sayColor();</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">1.把sayName共有的方法抽象出来放到父类Animal构函的原型中，而子类构函Dog和Bird的原型都有自己特有的sayColor和sayType方法。如此实现继承，并且借用构函来减少代码的冗余问题。</span><br><span class="line"></span><br><span class="line">2.确定原型和实例的关系的方法：</span><br><span class="line">    </span><br><span class="line">      (1)原型.isPrototypeOf(instance)；只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型</span><br><span class="line"></span><br><span class="line">        console.log(Bird.prototype.isPrototypeOf(b1));</span><br><span class="line">        console.log(Animal.prototype.isPrototypeOf(b1));</span><br><span class="line">        console.log(Object.prototype.isPrototypeOf(b1));</span><br><span class="line"></span><br><span class="line">      (2)instanceof()，判断某个实例是不是某个构造函数的实例，只要是原型链中一条完整原型链里出现的构造函数，那么就是这些出现构造函数都算是这个实例的构函，结果为true。</span><br><span class="line"></span><br><span class="line">        console.log(d1 instanceof Object);</span><br><span class="line">        console.log(d1 instanceof Dog);</span><br><span class="line">        console.log(d1 instanceof Animal);</span><br><span class="line">    </span><br><span class="line">3.构造函数中的方法 由构函创建的实例不能调用</span><br></pre></td></tr></table></figure>
<p>图片详细地址（高清）：<a href="/images/web/组合.png">组合函数</a><br><img src="/images/web/组合.png" alt=""></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="javaScriptAPI学习"><a href="#javaScriptAPI学习" class="headerlink" title="javaScriptAPI学习"></a>javaScriptAPI学习</h1><p>本文记录了本人在大三期间自学javaScript的学习笔记，自学时用到的代码均上传至giuhub。该部分主要介绍的是js一些API,主要是我们开发时能调用的接口。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习了面向对象的几个方面，先总体概括一下学习的知识点。</p>
<ul>
<li><p>创建对象的封装</p>
<ol>
<li><p>工厂模式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factory(name,age)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        age:age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = factory(&quot;ls&quot;,12);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&quot;ls&quot;,12);</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型模式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&quot;ls&quot;,12);</span><br><span class="line">var result = p1 instanceof Person;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>继承(原型基础上)</p>
<ol>
<li><p>属性继承：借用构造函数继承（经典继承）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(id,name)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName=function()&#123;</span><br><span class="line">    cosnole.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Dog(id,name,color)&#123;</span><br><span class="line">    Animal.call(this,id,name);//this指向的是构函创建的内存中的新对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法继承：构造函数的原型</p>
<pre><code>Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;
var d = new Dog(1,&quot;tom&quot;,&quot;yellow&quot;);
d.sayName();//d可以调用Dog原型中的方法和Animal原型中,Object原型中的方法
</code></pre></li>
<li>属性和方法组合函数</li>
</ol>
</li>
<li><p>API:应用程序编程接口(application programing interface)</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js:官方API标准（别人写好的构函和构函原型，里面有方法和属性）</span><br><span class="line">java:官方API标准，自定义API</span><br><span class="line">CommonJS(模块化开发)</span><br></pre></td></tr></table></figure>
</li>
<li><p>学前的几个问题：</p>
<ul>
<li><p>与对象的区别和联系？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">联系：对象和数组都是由逗号分隔，并且最后一个属性后面不用逗号,创建数组和创建对象的方式差不多</span><br><span class="line"></span><br><span class="line">区别：属性名不一样，对象的属性名是自定义的字符串类型，而数组的属性名是从0开始的有序数值列表</span><br><span class="line">对象的访问obj[&quot;name&quot;]和数组的访问arr[0];访问方式都是 对象/数组[属性名]。对象的属性和数组的索引实质是一个意思</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量重名问题  后面的覆盖了前面的变量</p>
</li>
<li>数组调用时的this指向    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设 var arr = [1,&quot;terry&quot;,function()&#123;</span><br><span class="line">    console.log(this.length);</span><br><span class="line">&#125;];</span><br><span class="line">console.log(arr[2]());//length = 3,this --&gt; arr</span><br><span class="line">arr[2]();//跟对象调用一样 arr.2(); 2表示方法名，那么arr就是this的指向。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p><strong>构函,有个原型Array.prototype</strong></p>
<ul>
<li>目前学习数组构函原型中的共有方法</li>
<li>原型中存储着共有的方法供构造函数创建的实例使用</li>
<li>构造函数的方法不能被实例调用：Array构函中的方法通过Array.调用，而不能实例对象.调用</li>
<li><p>Array的实例arr可以调用Array.prototype中的方法</p>
<ol>
<li><p>实例对象的创建方式<br> (1)用构造函数创建</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();/[]</span><br><span class="line">参数的三种情况： 无参 :相当于空数组[]</span><br><span class="line">                一个整数 : 创建指定长度length的数组，每一个数组的值都是undefined  new Array(20);若为小数报错</span><br><span class="line">                多个值 :创建一个数组并且使用实参进行初始化数组   new Array(1,2,&quot;fff&quot;);</span><br></pre></td></tr></table></figure>
</code></pre><p> (2)字面量</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2];用逗号分隔，但是最后一个元素的后面不能放逗号</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>数组的访问:arr[索引],索引可以超过数组的边界,超过的部分为undefined</p>
</li>
<li><p>数组的遍历</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    console.log(i,arr[i]);//为undefined的也会被打印出来</span><br><span class="line">&#125;</span><br><span class="line">2.while()&#123;&#125;</span><br><span class="line"></span><br><span class="line">3.do&#123;&#125;while()</span><br><span class="line">4.for(var key in arr)&#123;</span><br><span class="line">    key ：索引 ; arr[key]:值</span><br><span class="line">    //for in循环中当改变length之后那些为undefined的值不会被打印出来</span><br><span class="line">&#125;</span><br><span class="line">5.数组中的迭代方法：下面的几个方法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组检测</p>
<p> 1.Array（构函）可以调用的方法isArray方法，是声明在构造函数中的。</p>
<pre><code>Array.isArray(arr)判断指定变量是否是数组
</code></pre><p> 2.instanceof方法 检测实例对象是否是某构函创建的实例 arr instanceof Array;</p>
</li>
<li><p>数组的属性</p>
<pre><code>length 长度（数组中拥有元素的个数）
    length 可读可写(可以改变)
    arr.length = 4;
</code></pre></li>
<li><p>数组对象可以调用的方法（数组原型中的方法）</p>
<pre><code>var arr = new Array();

1.数组序列化（数组转换为字符串）：分隔符不管是几个单词组成都占1个长度；为undefined的项不会被序列化为字符串

    1)toString() 默认的将数组项用逗号分隔 
        var arr = [1,2,5,0];
        arr[7] = &quot;terry&quot;;
        console.log(arr.toString(),&quot;length:&quot;+arr.length);//1,2,5,0,,,,terry  length:8

    2)join() 传参之后可以自定义分隔项，以你定义的参数为准
        var arr = [1,2,5,0];
        arr[7] = &quot;terry&quot;;
        console.log(arr.join(&apos;ss&apos;),&quot;length:&quot;+arr.length);//1ss2ss5ss0ssssssssterry length:8

2.栈: 先进后出(改变原数组)

    1)入栈push()
        功能：可接受任意类型的参数，将他们逐个添加到数组尾部，并返回数组长度
        参数 ：可多个
        返回值：返回新数组长度 
            var arr = [1,2,3];
            console.log(arr.push(&quot;larry&quot;,1));//5
    2)弹栈pop()
        功能：从数组的末尾移除最后一项，减少数组的长度，并返回这个移除的项
        参数：无
        返回值：返回移除项
            var arr = [&quot;larry&quot;,&quot;teerr&quot;,&quot;jack&quot;];
            var result =arr.pop(); // result为方法的返回值
            console.log(&quot;result:&quot;,result);//jack
            console.log(&quot;arr:&quot;,arr);//[&quot;larry&quot;,&quot;teerr&quot;]
3.队列：(改变原数组)

    1)入队unshift
        功能：在数组最添加任意项，并且返回新数组的长度
        参数：任意个
        返回值：返回新数组长度
            var arr = [1,true,null];
            var result = arr.unshift(&quot;larry&quot;);
            console.log(&quot;result:&quot;,result);//4
            console.log(&quot;arr:&quot;,arr);//[&quot;larry&quot;,1,true,null]
    2)出队shift
        功能：移除数组中的第一项，减少数组长度，并且返回移除项的值
        参数：无
        返回值：返回移除项
            var arr = [&quot;larry&quot;,1,true,null];
            var result = arr.shift();
            console.log(&quot;result:&quot;,result);//larry
            console.log(&quot;arr:&quot;,arr);//[1,true,null]
4.排序

    1)翻转reverse():改变原数组
            功能：翻转数组项
            参数：无
            返回值：返回了翻转后的新数组
                var arr = [1,2,3,4];
                console.log(&quot;before:&quot;,arr);//[1,2,3,4]
                var result = arr.reverse();
                console.log(&quot;after:&quot;,arr);//[4,3,2,1]
                console.log(&quot;返回值:&quot;,result);//[4,3,2,1]

    2)排序sort():
        默认排序：方法会调用每个数组项的toString()方法 把每项转换成字符串，然后按照字符编码表的顺序排序

        自定义排序：方法可以接受一个比较函数作为参数，比较函数有两个参数
                a.如果第一个参数位于第二个参数之前，返回负数
                b.如果第一个参数位于第二个参数之后，返回正数 
            1.降序
            if(a&gt;b){
                return -1;//降序
            }else if(a&lt;b){
                return 1;
            }else{
                return 0;
            }    
            2.升序
            if(a&gt;b){
                return 1;//升序
            }else if(a&lt;b){
                return -1;
            }else{
                return 0;
            }
5.截取方法
        1.concat()：不改变原数组
            功能：数组拼接，先创建当前数组的副本，然后将接收到的数组添加到副本的末尾，返回拼接后的副本
            参数：一个或者多个数组或者一部分参数列表
            返回值：返回拼接后数组
                var arr1 = [1,2,3];
                var arr2 = [4,5,6];
                console.log(&quot;before:&quot;,arr1,arr2);
                var result = arr1.concat(arr2);
                console.log(&quot;before:&quot;,arr1,arr2);
                console.log(&quot;result:&quot;,result);//[1,2,3,4,5,6]
        2.slice():不改变原数组
            功能：数组切割，可接受一个或两个参数（起始位置，结束位置），返回数组切割后的子字符串
            参数：当一个参数时，从该参数指定位置开始到当前数组的末尾的所有项；
                当两个参数时，表示起始到结束位置之间的项，不包括结束位置的项。
            返回值：返回切割后的子字符串
                var arr = [1,2,3,4,5,6,7,8,9];
                console.log(&quot;after:&quot;,arr);
                var result1 = arr.slice(5);// [6,7,8,9]
                var result2 = arr.slice(2,4);//[3,4]
                console.log(&quot;after:&quot;,arr);
                console.log(&quot;result:&quot;,result);

        3.splice():改变原数组
            功能：向数组中部插入数据将始终返回一个数组。该返回数组中包含从原始数组中删除的项

            参数：
                删除：指定两个参数（删除的起始位置，要删除的个数）
                插入：指定三个参数（起始位置，0，插入的任意数量的项）
                替换：指定三个参数（起始位置，要删除的项，要插入的任意数量的项）
            返回值：从原始数组中删除的项/截取的子字符串（第二种参数情况返回0）

6.索引方法:查找元素的索引
        1.indexOf()：返回索引
            功能：从数组开头向后查找，使用全等操作符，找不到该元素返回-1。
            参数：第一个参数为要查找的项（元素），第二个参数（可选）为查找索引的开始位置（把-1看成最后一项算）
                    第二个参数可为正负数，
                            正数表示从前从后找到索引位置，再进行从前从后算元素所在索引位置；
                            负数表示从后往前找到索引所在位置，再进行从前从后算元素所在索引位置。
            返回值：元素对应的索引

        2.lastIndexOf()
            功能：从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。
            参数：第一个参数为要查找的项（元素），第二个参数（可选）为索引开始位置（查找的索引开始位置）
                 第二个参数可为正负数，
                            正数表示从前从后找到开始索引位置，再进行从后往前算元素所在索引位置；
                            负数表示从后往前找到开始索引所在位置，再进行从后往前算元素所在索引位置。
            返回值：元素对应的索引

7.迭代方法(底层代码是循环语句) 每次循环遍历后调用一次匿名函数
</code></pre><p> ????????????????1.forEach() </p>
<pre><code>功能：对数组中的每一项运行给定的函数，没有返回值，常用于遍历元素
参数：回调函数
返回值：无
arr.forEach(function(item,index,arr){
    //item 项  index:下标 arr:当前正在遍历的数组
})

var arr = &apos;12434&apos;.split(&quot;&quot;);
    arr.forEach(function(item,index,arr){
        // +arr[index];
        arr[index]+1;
})??????????
</code></pre></li>
</ol>
</li>
</ul>
<pre><code>2.map():不改变原数组
    功能：对数组的每一项运行给定的函数，返回值为每次调用函数结果的新数组.对数组复制一份然后对这个复制的数组进行函数运算，再返回复制的改变后的数组
    参数：回调函数 
        map(function(item,index,arr){
            return item;
        })
    返回值：返回调用回调函数后组成的新数组

3.filter()：过滤
    功能：对数组中的每一项运行给定的函数，会返回满足该函数的项组成的数组
    参数：匿名函数

    返回值：返回值是true的 组成的新数组
        var result = arr.filter(function(item,index,arr){
            return item&lt;2;//布尔表达式
        });
        console.log(result); // [11, 5, 23, 7, 4, 9]

4.some()：一些(或)
    功能：对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true  
    参数：匿名函数
    返回值：返回布尔值true或者false.

        var result = arr.every(function(item,index,arr){
            return item &lt;2;
        });
        console.log(result); //true,

5.every()：每一(并)
    功能：对数组中的每一运行给定的函数，如果该函数对每一项都返回true,则该函数返回true
    参数： 每一项上运行的匿名函数；运行该函数的作用域对象（可选）
    返回值：返回值：返回布尔值true或者false.

        var arr = [11,5,23,7,4,1,9,1];
        var result = arr.every(function(item,index,arr){
            return item &lt;2;
        });
        console.log(result); //false
</code></pre><h2 id="Function-函数的构造函数"><a href="#Function-函数的构造函数" class="headerlink" title="Function:函数的构造函数"></a>Function:函数的构造函数</h2><pre><code>##函数

    1.在js中，使用Function可以实例化函数对象，也就是说在js中函数与普通对象一样，也是一个对象类型。
    2.函数是对象，就可以使用对象的动态特性
    3.函数是对象，就有构造函数创建函数
    3.函数是函数，可以创建其他对象
    4.函数是唯一可以限定变量作用域的结果
    5.要解决的问题

      * Function如何使用
      * Function与函数的关系
      * 函数的原型链结构

###函数(普通函数和构造函数)是 Function的实例

    1.语法
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Function(arg0,arg1,arg2,arg3,...argn,body);</span><br></pre></td></tr></table></figure>

    2.Function中的参数全部都是字符串
    3.该构造函数参数的作用是将参数连接起来组成函数

      * 如果参数只有一个，表示函数体
      * 如果参数有多个，那么最后一个表示函数体，前面的所有参数表示函数的参数
      * 如果没有参数，表示创建一个空函数
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//只带一个参数的情况</span><br><span class="line">// 传统的函数 </span><br><span class="line">  function foo()&#123;</span><br><span class="line">    console.log(&quot;你好&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //Function构函</span><br><span class="line">  var fuc=new Function(&apos;console.log(&quot;你好&quot;);&apos;);</span><br><span class="line">  foo();</span><br><span class="line">  fuc();</span><br><span class="line">  //功能是一样的</span><br></pre></td></tr></table></figure>


            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//没有任何参数的</span><br><span class="line">var foo=new Function();</span><br></pre></td></tr></table></figure>

            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//带有参数的</span><br><span class="line">var foo=new Function(&quot;num&quot;,&quot;console.log(num)&quot;;);</span><br></pre></td></tr></table></figure>

4.例题：写一个函数，实现输出三个数中的最大数
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传统实现方法</span><br><span class="line">   function sum( a , b , c )&#123;</span><br><span class="line">    var reg = a 大于 b ? a : b;</span><br><span class="line">    reg = reg 大于 c ? reg : c;</span><br><span class="line">    return reg;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(sum(123,234,4));</span><br><span class="line">用Function构函实现</span><br><span class="line">   var sum=new Function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;var reg = a &gt; b ? a : b;reg = reg &gt; c ? reg : c;return reg;&quot;)</span><br><span class="line">   console.log(sum(123,234,4));</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="RegExp正则表达式：是一个描述字符模式的对象"><a href="#RegExp正则表达式：是一个描述字符模式的对象" class="headerlink" title="RegExp正则表达式：是一个描述字符模式的对象"></a>RegExp正则表达式：是一个描述字符模式的对象</h2><pre><code>* 网站：hackerrank.com(做题)和regexr.com(查询)

* RegExp()构造函数，由构函创建的实例可以调用RegExp.prototype原型中的方法。

    1. 创建
        1）构造函数创建：
        var pattern = new RegExp(&quot;正则表达式&quot;,&quot;修饰符&quot;);  

        var pattern = new RegExp(&quot;hello&quot;,&quot;gi&quot;);
        console.log(pattern);//   /hello/gi

        2）正则字面量：
        var pattern =/正则/修饰符;

        var pattern = /hello/gi; 
        console.log(pattern);//  /hello/gi（正则表达式）

            &amp;修饰符：不是出现在两条斜线之间，而是出现在第二条斜线之后的。

                i   ignoreCase 不区分大小写
                g   global      全局检索，找到所有的匹配，而不是找到第一个之后就停止
                m   multiline   多行
                    eg: /java/im 这个模式可以匹配不区分大小写和多行里的java

    2.(实例原型)属性
        *lastIndex:下一次匹配的开始位置,是正则表达式的属性。
        如果模式带有修饰符g时，这个属性存储在整个字符串中下一次检索的开始位置。

            var str = &quot;javascript is good ,it is easy than ja&quot;;
            var pattern3 =/java/g;
            var result = pattern3.exec(str);
            console.log(result); //[&quot;java&quot;]
            console.log(pattern3); //java/gi

            console.log(pattern3.lastIndex); //(第一次匹配java后，下一次匹配的开始位置) 4

            var result = pattern3.exec(str);
            console.log(result); // null
            console.log(pattern3); //java/gi

            console.log(pattern3.lastIndex);//0


        *source :正则表达式的文本 ，是一个只读字符串
            var pattern = /hello/gi;
            console.log(pattern.source); //hello是正则的文本

        *global :布尔值，表明这个正则表达式是否带有g修饰符
            console.log(pattern.global);//true

        *ignoreCase：布尔值，表明这个正则表达式是否带有i修饰符
            console.log(pattern.ignoreCase);//true

        *multiline:布尔值，表明这个正则表达式是否带有m修饰符
            console.log(pattern.multiline);//false

    3.模式（正则实例对象）的方法(在RegExp.prototype中的方法)
        RegExp 原型中的方法，是js提供的，实例可以调用

        * 模式.方法(字符串);

        1) test(str) ：测试
            作用： 测试传入的参数是否匹配正则
            参数： 待检测的字符串
            返回值：boolean,如果匹配返回true,否则返回false

                var pattern = /hello/i;
                var res = pattern.test(&quot;dgh hello fd&quot;);
                console.log(res);//true

        2) exec(str) ：查找
            （全局匹配时每次调用都会修改一次模式 pattern的lastIndex），需要循环调用

            作用： 执行检索操作

            参数： 待检测的字符串

            返回值: 
                *数组，数组中第一项保存的是匹配到的文本，后面的项保存的是子表达式（子类()），
                *[整体匹配的内容,第一项分组匹配的内容，第二项分组...]
                *每次调用此方法匹配的文本都不是同一个，index值是不一样的。

                    1.返回数组的属性：
                        数组.index  数组中匹配字符串出现的起始位置
                        数组.input  原字符串内容
                    2.实例对象pattern会被影响
                    如果是全局检索，会维护lastIndex，用来标识下一次检索开始的位置。
                    3.如果没有匹配到任何结果，将lastIndex重置为0,返回值结果为null.
                        var str = &quot;javascript is good ,it is easy than ja&quot;;
                        var pattern3 =/java/g;
                        //如果不加g修饰符，则每次循环查找到的子字符串都是一样的，并且找到第一个就停止查找。
                        var res;
                        while(res = pattern3.exec(str)){//当pattern3.exec(str)为null时不会进入while循环
                            console.log(res);
                            console.log(pattern3.lastIndex);
                        }
                        //当循环结束后在查看lastIndex,他们的值都为0;因为pettern3是同一个对象

        3)toString() :将正则转换为字符串
            var res = pattern.toString();
            console.log(res);//  &apos;/^\d{3,}/g&apos;

    4.字符串的方法（字符串对正则的支持）

        * 字符串.方法(模式)；

        1)match()方法
            与exec()方法类似
                功能：检索
                参数：正则表达式
                返回值：

                    * 当正则不用g修饰符时，返回值是一个 第一项为查找的子字符串，后面的项为子类（子表达式）组成的数组，和exec()方法返回值一样。

                    * 但是当正则用g修饰符时，返回值为查找到的所有匹配的项组成的数组（子模式（子表达式）的内容不会出现）

            console.log(&apos;1 pius 2 equals 3&apos;.match(/\d+/));
            //不加g跟exec返回值差不多,也有input和Index属性
            //[&quot;1&quot;,...(子串) index: 0, input: &quot;1 pius 2 equals 3&quot;]

            console.log(&apos;1 pius 2 equals 3&apos;.match(/\d+/g));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]

        2)serach() 查找并返回索引
            功能：
                * 不支持全局检索，它会忽略修饰符g。
                * 在遇到第一个匹配的子串时就会返回它的起始位置;遍历完所有，找不到就会返回-1。
                * 如果参数不是正则表达式，则首先会通过RegExp构函将它转换为正则表达式。
            参数：一个正则表达式或者其他字符串。
            返回值：索引，返回第一个与之匹配的子串的起始位置，如果找不到将返回-1.

                console.log(&apos;javascript&apos;.search(/script/i));//4
                console.log(&apos;javascript&apos;.search(&apos;script&apos;));//4

        3)replace() 检索并替换
            功能：
                * 对调用它的字符串进行检索并替换，使用指定模式来匹配，不会对原文本进行改变
                * 如果正则表达式设置了g,则进行全局检索并替换;如果没有g,则只替换第一个被找到的子串。
                * 如果第一个参数不为正则表达式，则将直接搜索这个字符串，而不是像search一样转换为正则。

            参数：第一个参数是正则表达式，第二个参数是要进行替换的字符串

            返回值：返回替换之后的文本。

                var txt = &apos;javascript is good,java is more&apos;;
                var res = txt.replace(/java/gi,&apos;Java&apos;);
                var res1 = txt.replace(&apos;java&apos;,&apos;Java&apos;);

                console.log(res);  //Javascript is good,Java is more
                console.log(res1); //Javascript is good,java is more 只找到第一个字符串并替换。
                console.log(txt); //javascript is good,java is more不改变原值

        4)split():
            功能：将调用它的字符串拆分为数组，分隔符是split的参数
            参数：分隔符
            返回值：数组
                var res = &apos;1.2.3.4.5&apos;.split(/\./g);//将字符串按照你给的参数进行字符串分割
                console.log(res);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]

    2. 正则表达式的匹配
        1) 字符直接量（只能匹配一个）
            abc 字符串
            .   所有字符
            \.  匹配特殊字符&apos;.&apos;
            \w  [a-zA-Z0-9_]
            \W  [^a-zA-Z0-9_]
            \s  [\n\t\f\r]
            \S  [^\n\t\f\r]
            \d  [0-9]
            \D  [^0-9]
            要匹配其他的直接量等只需加转义符\

        2) 字符类：将直接量字符单独放在方括号内就组成了一个字符类（只能匹配一个）

            [a-z]
            [0-9]
            [a|b]
            [abcd] 匹配包含a|b|c|d其中一个的一个字符

        3) 数量（默认是贪婪匹配的）

            字符/字符/分组{数量}
            {n}
            {n,m}
            {n,}
            ? 匹配0-1次 {0,1}
            * 匹配0-多次 {0,}
            + 匹配1-多次 {1,}

        4) 贪婪匹配（默认）与非贪婪匹配
            非贪婪匹配只需在表示数量的后面加?
            {数量}?
            /\d+?/gi 匹配一次

        5) 边界匹配
            ^ 开始边界： ^abc    如果用在字符类[]内，表示非

            $ 结束边界  \w$
            (?=p) 零宽正向先行断言，要求接下来的字符都与p匹配
                /[jJ]ava([Ss]cript)?(?=\:)/
                可以匹配&quot;javascript:the defined duide&quot;
                不能匹配&quot;java in a nutshell&quot;

            (?!p) 零宽负向先行断言，要求接下来的字符不与p匹配
                /java(?! script)([A-Z]\w*)/
                可以匹配带script，也可以不匹配

        6) 选择匹配 ：|（或者）
            /a|b|c|d|e|f/
            /[a-f]/


        7) 分组 ：()
            1.把单独项组成子表达式，以便可以像处理一个独立单元一样用? * 等对单元项进行处理
                var pattern = /Java(script)?/gi; //可以匹配java/javascript
            2.在完整的模式中定义子模式

            3.允许在同一正则表达式后部引用前面的子表达式,通过\数字调用前面的子表达式

        8) 引用 ：\数字
            对正则表达式中前一个表达式的引用
            var pattern = /[&apos;&quot;][^&apos;&quot;]*[&apos;&quot;]/g;
            var pattern = /([&apos;&quot;])[^&apos;&quot;]/gi;//使用引用,引用的是第一个子类
</code></pre><h2 id="包装器数据类型-String-Boolean-Number"><a href="#包装器数据类型-String-Boolean-Number" class="headerlink" title="包装器数据类型:String  Boolean  Number"></a>包装器数据类型:String  Boolean  Number</h2><pre><code>*为了便于操作基本数据类型，ECMAScript提供了三个特殊的引用类型String Boolean Number。每当读取一个基本数据类型值的时候，后台就会创建一个对应的基本包装类型对象，从而可以使我们调用这些对象的原型的方法实现一些操作。

*后台自动完成的操作
 eg: var s = &quot;briup;
     s.substring(2);
     自动完成三个步骤：
        a.创建String类型的一个实例
        b.在实例上调用指定的方法
        c.销毁这个实例

* object() 构函会像工厂方法一些，它会根据传入的值的类型返回相应基本包装器类型的实例
    var obj1 = new Object();//不传参的时候默认是Object的实例（东西）
    console.log(obj1 instanceof Object);//true

    var obj2 = new Object(&quot;briup&quot;);//传参时就会根据参数的类型创建相应的包装器实例对象，可以调用相应构函的原型的方法
    console.log(obj2 instanceof String);//true
    console.log(obj2 instanceof Object);//true

    var obj3 = new Object(12);
    console.log(obj3 instanceof Number);//true

*使用new调用基本包装类型的构造函数创建实例对象和直接调用同名的构造转换函数不一样
    var a = 123;
    var c =Number(a);//直接调用构造函数进行数据类型转换 number类型
    var b = new Number(123);//用new 来调用构造函数创建实例对象 Object类型

    console.log(a==b);//true
    console.log(a===b);//false
    console.log(a===c);//true

    console.log(typeof a);//number
    console.log(typeof b);//object
    console.log(typeof c);//number

    console.log(b instanceof Number);//true

* 基本包装数据类型：不包括null和undefined

    1.Boolean
    2.Number
        不建议直接使用这两种包装器类型

    3.String类型

        * var str = &apos;hello&apos;;
        // 根据自动完成操作，str会是String的一个实例，String.prototype定义的方法 str实例都可以调用

        * 与数组中的属性和方法联系起来

        1)属性:(String.prototype中的)
            length:获取给定字符串的字符长度

        2)方法:(String.prototype中的)

            * charAt(i) （英译:在哪个下标的字符）
             返回给定位置的字符

            * charCodeAt() 返回给定位置的字符的字符编码(ASCII)
                例如:
                var s = &quot;helloworld&quot;;
                s.charAt(1);       //e
                s.charCodeAt(1); //101

            * indexOf(英译:谁的下标)
            从前往后查找指定字符所在位置,与数组方法类似，可以传两个参

            * lastIndexOf();  从后往前查找字符串所在位置，可以有第二个参数，代表从符串中哪个位置开始查找。与数组方法类似

            * concat() ：不改变原有的字符串
            将一个或多个字符串拼接起来，返回拼接得到的新字符串，但是大多使用&quot;+&quot;拼接

            * slice() :不改变原有的字符串
            截取字符串（开始位置，结束位置），第二个参数不给时则截取到最后位置。

            * substring()：不改变原有的字符串
            截取字符串（开始位置，结束位置）第二个参数不给时则截取到最后位置。

            * substr() ：截取字符串（开始位置，返回字符个数）,跟数组中splice有不一样的，substr必须给两个参数

                var s = &quot;helloworld&quot;;
                s.slice(3,7);    //lowo
                s.substr(3,7);   //loworld
                s.substring(3,7);//lowo
                s.substring(3);//loworld

            * trim() :不改变原字符串
            删除前置以及后置中的所有空格（最左和最右的空格，不会去掉中间的），返回结果
                var str = &quot; javascript is good &quot;;
                var result = str.trim();
                console.log(result);//&quot;javascript is good&quot;
                console.log(str);//&quot; javascript is good &quot;

            * toLowerCase():转换为小写

            * toUpperCase() :转换为大写
                var str = &quot;java&quot;;
                var result = str.toUpperCase();
                console.log(result);//JAVA
                console.log(str);//java

        后面四个方法具体参照正则表达式的方法解析(P832页)
            * split
                在指定的分隔符字符串或者正则表达式处断开，将一个字符串分割为由字符串组成的数组。
                参数是分隔符，表示的是将这个字符串按照字符串中有的字符来进行分隔成数组，数组的每项依然的字符串。

                    console.log(&apos;1226&apos;.split(&apos;,&apos;));//[&apos;1226&apos;] 字符串中没有逗号，则把整个字符串变成数组唯一项
                    console.log(&apos;1236&apos;.split(&apos;&apos;));//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;6&quot;]
            * replace
                使用正则表达式执行查找和替换操作，如果第一个参数不是正则而是普通字符串，那么将找到第一个匹配的字符串并替换。
            * serach
                不支持全局检索，找到符合的第一个就返回它的起始索引，否则就返回-1.
            * match
                使用正则进行模式匹配，如果不是全局则与exec方法一样，如果是全局那么将返回找到的所有的子串组成的数组。
</code></pre><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><pre><code>没有构造函数，只是单纯的对象。包含一些数学函数(方法)和常量(属性)。
    属性：
        Math.E   数学常数 E
        Math.LN10 数学常数 log e(下标) 10==ln10
        Math.PI  数学常数 PI

    方法：
    1)常用方法
        1.比较方法
            Math.min()  求一组数中的最小值
            Math.max()  求一组数中的最大值
                Math.min(1,2,19,8,6);   //1
        2.将小数值舍入为整数的几个方法：
            Math.ceil()  向上舍入
            Math.floor() 向下舍入
            Math.round() 四舍五入

                console.log(Math.ceil(12.41));  //13
                console.log(Math.floor(12.41)); //12
                console.log(Math.round(12.3));  //12
                console.log(Math.round(12.5));  //13
        3.随机数
            Math.random() 返回大于0小于1的一个随机数

    2)其他方法  
        abs(num)        返回num绝对值
        exp(num)        返回Math.E的num次幂
        log(num)        返回num的自然对数

        pow(num,power)  返回num的power次幂
        sqrt(num)       返回num的平方根

        scos(x)         返回x的反余弦值
        asin(x)         返回x的反正弦值
        atan(x)         返回x的反正切值
        atan2(y,x)      返回y/x的反正切值
        cos(x)          返回x的余弦值
        sin(x)          返回x的正弦值
        tan(x)          返回x的正切值
</code></pre><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><pre><code>1.Date对象，是操作日期和时间的对象。Date对象对日期和时间的操作只能通过方法。

2.属性:
    无；Date对象对日期和时间的操作只能通过方法。


3.创建Date对象(Date()构造函数)
  * 不使用new关键字创建
    console.log(Date());
    consoel.log(typeof Date());  //string

        区别：
        不使用new 关键字创建的是基本数据类型
        用new关键字创建的是date对象，引用数据类型

  * 使用new关键字创建

    1)new Date() ：返回当前的本地日期和时间

        参数：无

        返回值： {Date} 返回一个表示本地日期和时间的Date对象。

            示例：

            var dt = new Date(); 
            consoel.log(typeof new Date()); //object
            console.log(dt); // 返回一个表示本地日期和时间的Date对象


    2) new Date(milliseconds) ：把毫秒数转换为Date对象

        参数：milliseconds {int} ：毫秒数；表示从&apos;1970/01/01 00:00:00&apos;为起点，开始叠加的毫秒数。

        注意：起点的时分秒还要加上当前所在的时区，北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;

        返回值：{Date} 返回一个叠加后的Date对象。

            示例：

            var dt = new Date(1000 * 60 * 1); // 前进1分钟的毫秒数
            console.log(dt); // {Date}:1970/01/01 08:01:00
            dt = new Date(-1000 * 60 * 1); // 倒退1分钟的毫秒数
            console.log(dt); //  {Date}:1970/01/01 07:59:00


    3)new Date(dateStr) ：把字符串转换为Date对象

        参数： ①dateStr {string} ：可转换为Date对象的字符串(可省略时间)；这里的年月日都是按照写的来算，不按照0开始计算.
        字符串的格式主要有两种：

            1) yyyy/MM/dd HH:mm:ss （推荐）：若省略时间，返回的Date对象的时间为 00:00:00。

            2) yyyy-MM-dd HH:mm:ss ：若省略时间，返回的Date对象的时间为 08:00:00(加上本地时区)。若不省略时间，此字符串在IE中会转换失败!

            3)也可以直接传一个由Date()创建的时间字符串进去，可以把它转换为对象
                new Date(Date());//get the local time

        返回值：{Date} 返回一个转换后的Date对象。

            示例：

            var dt = new Date(&apos;2014/12/25&apos;); // yyyy/MM/dd
            console.log(dt); //  {Date}:2014/12/25 00:00:00
            dt = new Date(&apos;2014/12/25 12:00:00&apos;); // yyyy/MM/dd HH:mm:ss
            console.log(dt); // {Date}:2014/12/25 12:00:00

            dt = new Date(&apos;2014-12-25&apos;); // yyyy-MM-dd
            console.log(dt); //  {Date}:2014-12-25 08:00:00 (加上了东8区的时区)

            dt = new Date(&apos;2014-12-25 12:00:00&apos;); // yyyy-MM-dd HH:mm:ss (注意：此转换方式在IE中会报错！)
            console.log(dt); // {Date}:2014-12-25 12:00:00

            var date = new Date(Date());
            console.log(date);//Sun Sep 03 2017 09:28:44 GMT+0800 (中国标准时间)

    4) new Date(year, month, opt_day, opt_hours, opt_minutes, opt_seconds, opt_milliseconds) ：把年月日、时分秒转换为Date对象

        参数：(最少传两个参数，如果参数是一个时，会显示1970/1/1 8:00:00)

            ①year {int} ：年份；4位数字。如：1999、2014

            ②month {int} ：月份；2位数字。从0开始计算，0表示1月份、11表示12月份。

            ③opt_day {int} 可选：号； 2位数字；从1开始计算，1表示1号。

            ④opt_hours {int} 可选：时；2位数字；取值0~23。

            ⑤opt_minutes {int} 可选：分；2位数字；取值0~59。

            ⑥opt_seconds {int} 可选：秒；2未数字；取值0~59。

            ⑦opt_milliseconds {int} 可选：毫秒；取值0~999。

        返回值：{Date} 返回一个转换后的Date对象。

            示例：
            var date = new Date(2012);//Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)  

            var dt = new Date(2014, 11); // 2014年12月(这里输入的月份数字为11)
            console.log(dt); //  {Date}:2014/12/01 00:00:00
            dt = new Date(2014, 11, 25); // 2014年12月25日
            console.log(dt); //  {Date}:2014/12/25 00:00:00
            dt = new Date(2014, 11, 25, 15, 30, 40); // 2014年12月25日 15点30分40秒
            console.log(dt); //  {Date}:2014/12/25 15:30:40
            dt = new Date(2014, 12, 25); // 2014年13月25日(这里输入的月份数字为12，表示第13个月，跳转到第二年的1月)
            console.log(dt); //  {Date}:2015/01/25


4. 实例方法(实例对象可以调用的)

    Date对象的实例方法主要分为2种形式：本地时间和UTC时间。同一个方法，一般都会有此2种时间格式操作(方法名带UTC的，就是操作UTC时间)，这里主要介绍对本地时间的操作。


    3.1 get方法
        3.1.1 getFullYear() ：返回Date对象的年份值；4位年份。

    *** 3.1.2 getMonth()：返回Date对象的月份值。从0开始，所以真实月份=返回值+1 。

        3.1.3 getDate() ：返回Date对象的月份中的日期值；值的范围1~31 。

        3.1.4 getHours() ：返回Date对象的小时值。

        3.1.5 getMinutes() ：返回Date对象的分钟值。

        3.1.6 getSeconds() ：返回Date对象的秒数值。

        3.1.7 getMilliseconds() ：返回Date对象的毫秒值。

    *** 3.1.8 getDay() ：返回Date对象的一周中的星期值；0为星期天，1为星期一、2为星期二，依此类推

        3.1.9 getTime() ：返回Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;) 。

            示例：

            dt.getFullYear(); // 2014：年
            dt.getMonth(); // 11：月；实际为12月份(月份从0开始计算)
            dt.getDate(); // 25：日
            dt.getHours(); //  15：时
            dt.getMinutes(); //  30：分
            dt.getSeconds(); //  40：秒
            dt.getMilliseconds(); //  333：毫秒
            dt.getDay(); //  4：星期几的值 :真实星期 = 返回值 +1 
            dt.getTime(); //  1419492640333 ：返回Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;)


    3.2 set方法
        3.2.1 setFullYear(year, opt_month, opt_date) ：设置Date对象的年份值；4位年份。
        3.2.2 setMonth(month, opt_date) ：设置Date对象的月份值。0表示1月，11表示12月。
        3.2.3 setDate(date) ：设置Date对象的月份中的日期值；值的范围1~31 。
        3.2.4 setHours(hour, opt_min, opt_sec, opt_msec) ：设置Date对象的小时值。
        3.2.5 setMinutes(min, opt_sec, opt_msec) ：设置Date对象的分钟值。
        3.2.6 setSeconds(sec, opt_msec) ：设置Date对象的秒数值。
        3.2.7 setMilliseconds(msec) ：设置Date对象的毫秒值。
            示例：

            var dt = new Date();
            dt.setFullYear(2014); // 2014：年
            dt.setMonth(11); // 11：月；实际为12月份(月份从0开始计算)
            dt.setDate(25); //  25：日
            dt.setHours(15); // 15：时
            dt.setMinutes(30); //  30：分
            dt.setSeconds(40); //  40：秒
            dt.setMilliseconds(333); // 333：毫秒
            console.log(dt); // 2014年12月25日 15点30分40秒 333毫秒


    3.3 其他方法
        3.3.1 toString() ：将Date转换为一个&apos;年月日 时分秒&apos;字符串
        3.3.2 toLocaleString() ：将Date转换为一个&apos;年月日 时分秒&apos;的本地格式字符串
        3.3.3 toDateString() ：将Date转换为一个&apos;年月日&apos;字符串
        3.3.4 toLocaleDateString() ：将Date转换为一个&apos;年月日&apos;的本地格式字符串
        3.3.5 toTimeString() ：将Date转换为一个&apos;时分秒&apos;字符串
        3.3.6 toLocaleTimeString() ：将Date转换为一个&apos;时分秒&apos;的本地格式字符串
        3.3.7 valueOf() ：与getTime()一样， 返回Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;) 
            示例：

                var dt = new Date();
                console.log(dt.toString()); // = Tue Dec 23 2014 22:56:11 GMT+0800 (中国标准时间) ：将Date转换为一个&apos;年月日 时分秒&apos;字符串
                console.log(dt.toLocaleString()); // = 2014年12月23日 下午10:56:11  ：将Date转换为一个&apos;年月日 时分秒&apos;的本地格式字符串

                console.log(dt.toDateString()); // = Tue Dec 23 2014 ：将Date转换为一个&apos;年月日&apos;字符串
                console.log(dt.toLocaleDateString()); // = 2014年12月23日 ：将Date转换为一个&apos;年月日&apos;的本地格式字符串

                console.log(dt.toTimeString()); // = 22:56:11 GMT+0800 (中国标准时间) ：将Date转换为一个&apos;时分秒&apos;字符串
                console.log(dt.toLocaleTimeString()); // = 下午10:56:11 ：将Date转换为一个&apos;时分秒&apos;的本地格式字符串

                console.log(dt.valueOf()); // = 返回Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;)


4. 静态方法(构造函数Date()可以调用的)
    4.1 Date.now()

        说明：返回当前日期和时间的Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;) 

        参数：无

        返回值：{int} ：当前时间与起始时间之间的毫秒数。

        示例：

        console.log(Date.now()); // = 1419431519276


    4.2 Date.parse(dateStr)

        说明：把字符串转换为Date对象 ，然后返回此Date对象与&apos;1970/01/01 00:00:00&apos;之间的毫秒值(北京时间的时区为东8区，起点时间实际为：&apos;1970/01/01 08:00:00&apos;)

        参数：①dateStr {string} ：可转换为Date对象的字符串(可省略时间)；字符串的格式主要有两种：

        1) yyyy/MM/dd HH:mm:ss （推荐）：若省略时间，返回的Date对象的时间为 00:00:00。

        2) yyyy-MM-dd HH:mm:ss ：若省略时间，返回的Date对象的时间为 08:00:00(加上本地时区)。若不省略时间，此字符串在IE中返回NaN(非数字)!

        返回值：{int} 返回转换后的Date对象与起始时间之间的毫秒数。

            示例：

            console.log(Date.parse(&apos;2014/12/25 12:00:00&apos;)); // = 1419480000000
            console.log(Date.parse(&apos;2014-12-25 12:00:00&apos;)); // = 1419480000000  (注意：此转换方式在IE中返回NaN！)
</code></pre><ol start="5">
<li><p>实际操作<br> 5.1 获取倒计时</p>
<p> 说明：计算当前时间离目的时间相差多少天时分。</p>
<pre><code>示例：

/**
* 返回倒计时
* @param dt {Date}：目的Date对象
* @return {Strin} ：返回倒计时：X天X时X分
*/
function getDownTime(dt) {
    // 1.获取倒计时
    var intervalMsec = dt - Date.now(); // 目的时间减去现在的时间，获取两者相差的毫秒数
    var intervalSec = intervalMsec / 1000; // 转换成秒数
    var day = parseInt(intervalSec / 3600 / 24); // 天数
    var hour = parseInt((intervalSec - day * 24 * 3600) / 3600); // 小时
    var min = parseInt((intervalSec - day * 24 * 3600 - hour * 3600) / 60); // 分钟

    // 2.若相差的毫秒小于0 ,表示目的时间小于当前时间，这时的取的值都是负的：-X天-时-分，显示时，只显示天数前面为负的就行。
    if (intervalMsec &lt; 0) {
        hour = 0 - hour;
        min = 0 - min;
    }

    // 3.拼接字符串并返回
    var rs = day + &apos;天&apos; + hour + &apos;时&apos; + min + &apos;分&apos;;
    return rs;
}

// 当前时间：2014/12/28 13:26
console.log(getDownTime(new Date(&apos;2015/06/01&apos;))); // =154天10时33分
console.log(getDownTime(new Date(&apos;2014/01/01&apos;))); // = -361天13时26分
</code></pre></li>
</ol>
<pre><code>5.3 比较2个Date对象的大小

    说明：可以对比2者的与起始时间的毫秒数，来区分大小。

    示例：

    var dt1 = new Date(&apos;2015/12/01&apos;);
    var dt2 = new Date(&apos;2015/12/25&apos;);
    console.log(dt1 大于 dt2); // = false
</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code>JSON文件里的格式
    对象
        {
            &quot;name&quot;:&quot;terry&quot;,
            &quot;age&quot;:12
        }
    数组
        [&quot;terrt&quot;,12,{
            &quot;name&quot;:&quot;terry&quot;
        }]
JSON文件里的对象和数组在js中的格式
    对象
        &apos;{
            &quot;name&quot;:&quot;terry&quot;,
            &quot;age&quot;:12
        }&apos;
    数组
        &apos;[&quot;terrt&quot;,12,{
            &quot;name&quot;:&quot;terry&quot;
        }]&apos;
</code></pre><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p><a href="https://yangbo5207.github.io/wutongluo/" target="_blank" rel="noopener">基础进阶系列</a></p>

      
    </div>
    
    
    

    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #666;font-size:14px;">-------------进度条到了&nbsp;<i class="fa fa-paw" style="color:rgb(90,85,85)"></i>&nbsp;感谢您的阅读-------------</div>
    
</div>
      
    </div>

    
    <div>
          
            
          
    </div>
    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Sanr Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://chensanr.gitee.io/2018/08/23/js基础1/" title="ECMAScript">https://chensanr.gitee.io/2018/08/23/js基础1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ECMAScript/" rel="tag"><i class="fa fa-tag"></i> ECMAScript</a>
          
            <a href="/tags/语法以及api/" rel="tag"><i class="fa fa-tag"></i> 语法以及api</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/10/f-e/" rel="next" title="前端面试常见知识点">
                <i class="fa fa-chevron-left"></i> 前端面试常见知识点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/27/html基础/" rel="prev" title="HTML基础">
                HTML基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTM3NC8xNTkwMQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p88z46ccj.bkt.clouddn.com/avar.jpg"
                alt="Sanr Chen" />
            
              <p class="site-author-name" itemprop="name">Sanr Chen</p>
              <p class="site-description motion-element" itemprop="description">少时为行 长时为恕</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenjing123456" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1474189135@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.zhangxinxu.com/" title="张鑫旭" target="_blank">张鑫旭</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.daqianduan.com/" title="大前端" target="_blank">大前端</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.w3cplus.com/" title="w3cplus" target="_blank">w3cplus</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#javaScript的基本语法"><span class="nav-number">1.</span> <span class="nav-text">javaScript的基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js基本语法"><span class="nav-number">1.1.</span> <span class="nav-text">js基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.1.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">undefined</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#null-空引用数据类型，即将要指向一个引用数据类型"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">null: 空引用数据类型，即将要指向一个引用数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#boolean-布尔类型"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">boolean: 布尔类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#number-数值类型"><span class="nav-number">1.1.2.1.4.</span> <span class="nav-text">number: 数值类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String-字符串类型-“”-‘’"><span class="nav-number">1.1.2.1.5.</span> <span class="nav-text">String: 字符串类型 “” ‘’</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂数据类型：object"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">复杂数据类型：object</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">1.1.3.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强制转换（显式转换）"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">强制转换（显式转换）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动转换（隐式转换）"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">自动转换（隐式转换）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">1.2.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句"><span class="nav-number">1.3.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象实例"><span class="nav-number">1.4.</span> <span class="nav-text">对象实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">1.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数实例"><span class="nav-number">1.5.1.</span> <span class="nav-text">函数实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值传递和引用传递"><span class="nav-number">1.5.2.</span> <span class="nav-text">值传递和引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined的取值情况"><span class="nav-number">1.5.3.</span> <span class="nav-text">undefined的取值情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数提升和变量提升"><span class="nav-number">1.5.4.</span> <span class="nav-text">函数提升和变量提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#javaScript面向对象"><span class="nav-number">2.</span> <span class="nav-text">javaScript面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装（封装创建对象的函数）"><span class="nav-number">2.1.</span> <span class="nav-text">封装（封装创建对象的函数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承：本质是子构造函数的原型指向父构造函数的实例对象。"><span class="nav-number">2.2.</span> <span class="nav-text">继承：本质是子构造函数的原型指向父构造函数的实例对象。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#javaScriptAPI学习"><span class="nav-number">3.</span> <span class="nav-text">javaScriptAPI学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">3.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">3.2.</span> <span class="nav-text">Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-函数的构造函数"><span class="nav-number">3.3.</span> <span class="nav-text">Function:函数的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegExp正则表达式：是一个描述字符模式的对象"><span class="nav-number">3.4.</span> <span class="nav-text">RegExp正则表达式：是一个描述字符模式的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装器数据类型-String-Boolean-Number"><span class="nav-number">3.5.</span> <span class="nav-text">包装器数据类型:String  Boolean  Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math对象"><span class="nav-number">3.6.</span> <span class="nav-text">Math对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date"><span class="nav-number">3.7.</span> <span class="nav-text">Date</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-number">3.8.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶"><span class="nav-number">3.9.</span> <span class="nav-text">进阶</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sanr Chen</span>

  
</div>



  
  <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
  </span> <span class="post-meta-divider">|</span> 
  <span id="busuanzi_container_site_uv">总访客&nbsp;<span id="busuanzi_value_site_uv"></span></span> 
  <span class="post-meta-divider">|</span> 




<div class="theme-info">
  <div class="powered-by"> 
  </div>
  <span class="post-count">博客全站共104.3k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
